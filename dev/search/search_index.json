{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"mq-rest-admin","text":""},{"location":"#overview","title":"Overview","text":"<p>mq-rest-admin provides a Java mapping layer for MQ REST API attribute translations and command metadata. It wraps the complexity of the <code>runCommandJSON</code> endpoint behind typed Java methods that map 1:1 to MQSC commands, translate attribute names between developer-friendly <code>snake_case</code> and native MQSC tokens, and surface errors as structured exceptions.</p>"},{"location":"#key-features","title":"Key features","text":"<ul> <li>~144 command methods covering all MQSC verbs and qualifiers</li> <li>Bidirectional attribute mapping between developer-friendly names and MQSC parameters</li> <li>Idempotent ensure methods for declarative object management</li> <li>Bulk sync operations for configuration-as-code workflows</li> <li>Zero runtime dependencies beyond Gson (~280KB)</li> <li>Transport abstraction for easy testing with mock transports</li> </ul>"},{"location":"#build-coordinates","title":"Build coordinates","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.github.wphillipmoore&lt;/groupId&gt;\n    &lt;artifactId&gt;mq-rest-admin&lt;/artifactId&gt;\n    &lt;version&gt;0.1.0-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"#status","title":"Status","text":"<p>This project is in pre-alpha (initial setup). The API surface, mapping tables, and return shapes are under active development.</p>"},{"location":"#license","title":"License","text":"<p>GNU General Public License v3.0</p>"},{"location":"ai-engineering/","title":"AI-assisted engineering","text":""},{"location":"ai-engineering/#java-specific-quality-standards","title":"Java-specific quality standards","text":"<p>100% test coverage: Every line and branch of production code is covered by unit tests. Coverage is enforced as a CI hard gate via JaCoCo at the BUNDLE level.</p> <p>Formatting and style: Spotless with google-java-format enforces consistent 2-space indentation and import ordering. Checkstyle with <code>google_checks.xml</code> enforces naming and structural conventions.</p> <p>Static analysis: SpotBugs (max effort, low threshold) catches bug patterns. PMD catches code smells. Both run as CI hard gates.</p> <p>Validation pipeline: <code>./mvnw verify</code> runs the same checks as CI: formatting \u2192 style \u2192 compile \u2192 unit tests \u2192 integration tests \u2192 coverage \u2192 SpotBugs \u2192 PMD.</p>"},{"location":"architecture/","title":"Architecture","text":""},{"location":"architecture/#component-overview","title":"Component overview","text":"<p>In the Java implementation, the core components map to these classes:</p> <ul> <li><code>MqRestSession</code>: The main entry point. A single class (no mixin   decomposition) that owns connection details, authentication, mapping   configuration, diagnostic state, and all ~144 command methods plus 16   ensure methods. Created via a builder pattern.</li> <li>Command methods: Generated methods on <code>MqRestSession</code> (e.g.   <code>displayQueue()</code>, <code>defineQlocal()</code>, <code>deleteChannel()</code>). Each method is a   thin wrapper that calls the internal <code>mqscCommand()</code> dispatcher with the   correct verb and qualifier.</li> <li><code>AttributeMapper</code>: Handles bidirectional attribute translation using   <code>MappingData</code> loaded from a JSON resource file. See the   Mapping Pipeline for details.</li> <li>Exception hierarchy: Sealed exception classes rooted at <code>MqRestException</code>.   All are unchecked (<code>RuntimeException</code>), so callers are not forced to catch   them but can choose to handle specific subtypes.</li> </ul>"},{"location":"architecture/#request-lifecycle","title":"Request lifecycle","text":"<p>In Java, the command dispatcher is the internal <code>mqscCommand()</code> method on <code>MqRestSession</code>. Every public command method (e.g. <code>displayQueue()</code>, <code>defineQlocal()</code>) delegates to it with the appropriate verb and qualifier.</p> <p>The session retains diagnostic state from the most recent command for inspection:</p> <pre><code>session.displayQueue(\"MY.QUEUE\");\n\nsession.getLastCommandPayload();    // the JSON sent to MQ\nsession.getLastResponsePayload();   // the parsed JSON response\nsession.getLastHttpStatus();        // HTTP status code\nsession.getLastResponseText();      // raw response body\n</code></pre>"},{"location":"architecture/#transport-abstraction","title":"Transport abstraction","text":"<p>In Java, the transport is defined by the <code>MqRestTransport</code> interface:</p> <pre><code>public interface MqRestTransport {\n    TransportResponse postJson(\n        String url,\n        Map&lt;String, Object&gt; payload,\n        Map&lt;String, String&gt; headers,\n        Duration timeout,\n        boolean verifyTls\n    );\n}\n</code></pre> <p>The default implementation, <code>HttpClientTransport</code>, uses <code>java.net.http.HttpClient</code> (JDK built-in). It accepts an optional <code>SSLContext</code> at construction for mTLS client certificate authentication.</p> <p>For testing, inject a mock or lambda transport:</p> <pre><code>MqRestTransport mockTransport = (url, payload, headers, timeout, verify) -&gt;\n    new TransportResponse(200, responseJson, Map.of());\n\nvar session = MqRestSession.builder()\n    .host(\"localhost\")\n    .port(9443)\n    .queueManager(\"QM1\")\n    .credentials(new LtpaAuth(\"admin\", \"passw0rd\"))\n    .transport(mockTransport)\n    .build();\n</code></pre> <p>This makes the entire command pipeline testable without an MQ server.</p>"},{"location":"architecture/#single-endpoint-design","title":"Single-endpoint design","text":"<p>In Java, this means every command method on <code>MqRestSession</code> ultimately calls the same <code>postJson()</code> method on the transport with the same URL pattern. The only variation is the JSON payload content.</p>"},{"location":"architecture/#gateway-routing","title":"Gateway routing","text":"<p>In Java, configure gateway routing via the session builder:</p> <pre><code>var session = MqRestSession.builder()\n    .host(\"qm1-host\")\n    .port(9443)\n    .queueManager(\"QM2\")           // target (remote) queue manager\n    .credentials(new LtpaAuth(\"mqadmin\", \"mqadmin\"))\n    .gatewayQmgr(\"QM1\")            // local gateway queue manager\n    .build();\n</code></pre>"},{"location":"architecture/#runtime-dependencies","title":"Runtime dependencies","text":"<p>The library has a single runtime dependency: Gson (~280KB) for JSON serialization. All other functionality uses JDK built-in APIs (<code>java.net.http.HttpClient</code>, <code>javax.net.ssl</code>).</p>"},{"location":"architecture/#package-structure","title":"Package structure","text":"<pre><code>io.github.wphillipmoore.mq.rest.admin\n    MqRestSession           \u2014 Main entry point (builder, commands, ensure, diagnostics)\n    MqRestTransport         \u2014 Transport interface\n    HttpClientTransport     \u2014 Default transport (java.net.http.HttpClient)\n    TransportResponse       \u2014 HTTP response record (statusCode, body, headers)\n\nio.github.wphillipmoore.mq.rest.admin.auth\n    Credentials             \u2014 Sealed interface\n    BasicAuth               \u2014 HTTP Basic authentication\n    LtpaAuth                \u2014 LTPA token-based authentication (auto-login)\n    CertificateAuth         \u2014 Client certificate authentication (mTLS)\n\nio.github.wphillipmoore.mq.rest.admin.exception\n    MqRestException         \u2014 Sealed base class (RuntimeException)\n    MqRestTransportException    \u2014 Network/connection failures\n    MqRestResponseException     \u2014 Malformed JSON, unexpected structure\n    MqRestAuthException         \u2014 Authentication/authorization failures\n    MqRestCommandException      \u2014 MQSC command returned error codes\n    MqRestTimeoutException      \u2014 Polling timeout exceeded\n\nio.github.wphillipmoore.mq.rest.admin.mapping\n    AttributeMapper         \u2014 Bidirectional attribute translation engine\n    MappingData             \u2014 Mapping tables loaded from JSON resource\n    MappingIssue            \u2014 Tracks individual mapping problems\n    MappingException        \u2014 Thrown on strict-mode mapping failure\n    MappingOverrideMode     \u2014 MERGE or REPLACE override strategy\n\nio.github.wphillipmoore.mq.rest.admin.ensure\n    EnsureAction            \u2014 Enum: CREATED, UPDATED, UNCHANGED\n    EnsureResult            \u2014 Record: action + changed attribute names\n</code></pre>"},{"location":"architecture/#ensure-pipeline","title":"Ensure pipeline","text":"<p>See ensure methods for details on the idempotent create-or-update pipeline.</p>"},{"location":"architecture/#sync-pipeline","title":"Sync pipeline","text":"<p>See sync methods for details on the synchronous polling pipeline.</p>"},{"location":"ensure-methods/","title":"Declarative Object Management","text":""},{"location":"ensure-methods/#the-problem-with-alter","title":"The problem with ALTER","text":"<p>Every <code>alter*()</code> call sends an <code>ALTER</code> command to the queue manager, even when every specified attribute already matches the current state. MQ updates <code>ALTDATE</code> and <code>ALTTIME</code> on every <code>ALTER</code>, regardless of whether any values actually changed. This makes <code>ALTER</code> unsuitable for declarative configuration management where idempotency matters \u2014 running the same configuration twice should not corrupt audit timestamps.</p>"},{"location":"ensure-methods/#the-ensure-pattern","title":"The ensure pattern","text":"<p>The <code>ensure*()</code> methods implement a declarative upsert pattern:</p> <ol> <li>DEFINE the object when it does not exist.</li> <li>ALTER only the attributes that differ from the current state.</li> <li>Do nothing when all specified attributes already match,    preserving <code>ALTDATE</code> and <code>ALTTIME</code>.</li> </ol> <p>Each call returns an <code>EnsureResult</code> indicating what action was taken:</p> <pre><code>import io.github.wphillipmoore.mq.rest.admin.ensure.EnsureAction;\nimport io.github.wphillipmoore.mq.rest.admin.ensure.EnsureResult;\n\n// EnsureAction enum values:\n//   CREATED   \u2014 Object did not exist, was defined\n//   UPDATED   \u2014 Object existed, attributes were altered\n//   UNCHANGED \u2014 Object existed, no changes needed\n\n// EnsureResult record:\n//   action()  \u2014 the EnsureAction taken\n//   changed() \u2014 attribute names that triggered ALTER\n</code></pre>"},{"location":"ensure-methods/#basic-usage","title":"Basic usage","text":"<pre><code>// First call \u2014 queue does not exist yet\nEnsureResult result = session.ensureQlocal(\n    \"APP.REQUEST.Q\",\n    Map.of(\n        \"max_queue_depth\", 50000,\n        \"description\", \"Application request queue\"\n    )\n);\nassert result.action() == EnsureAction.CREATED;\n\n// Second call \u2014 same attributes, nothing to change\nresult = session.ensureQlocal(\n    \"APP.REQUEST.Q\",\n    Map.of(\n        \"max_queue_depth\", 50000,\n        \"description\", \"Application request queue\"\n    )\n);\nassert result.action() == EnsureAction.UNCHANGED;\n\n// Third call \u2014 description changed, only that attribute is altered\nresult = session.ensureQlocal(\n    \"APP.REQUEST.Q\",\n    Map.of(\n        \"max_queue_depth\", 50000,\n        \"description\", \"Updated request queue\"\n    )\n);\nassert result.action() == EnsureAction.UPDATED;\nassert result.changed().contains(\"description\");\n</code></pre>"},{"location":"ensure-methods/#comparison-logic","title":"Comparison logic","text":"<p>The ensure methods compare only the attributes the caller passes in <code>requestParameters</code> against the current state returned by <code>DISPLAY</code>. Attributes not specified by the caller are ignored.</p> <p>Comparison is:</p> <ul> <li>Case-insensitive \u2014 <code>\"ENABLED\"</code> matches <code>\"enabled\"</code>.</li> <li>Type-normalizing \u2014 integer <code>5000</code> matches string <code>\"5000\"</code>.</li> <li>Whitespace-trimming \u2014 <code>\" YES \"</code> matches <code>\"YES\"</code>.</li> </ul> <p>An attribute present in <code>requestParameters</code> but absent from the <code>DISPLAY</code> response is treated as changed and included in the <code>ALTER</code>.</p>"},{"location":"ensure-methods/#selective-alter","title":"Selective ALTER","text":"<p>When an update is needed, only the changed attributes are sent in the <code>ALTER</code> command. Attributes that already match are excluded from the request. This minimizes the scope of each <code>ALTER</code> to the strict delta.</p>"},{"location":"ensure-methods/#available-methods","title":"Available methods","text":"<p>Each method targets a specific MQ object type with the correct MQSC qualifier triple (DISPLAY / DEFINE / ALTER):</p> Method Object type DISPLAY DEFINE ALTER <code>ensureQmgr()</code> Queue manager <code>QMGR</code> \u2014 <code>QMGR</code> <code>ensureQlocal()</code> Local queue <code>QUEUE</code> <code>QLOCAL</code> <code>QLOCAL</code> <code>ensureQremote()</code> Remote queue <code>QUEUE</code> <code>QREMOTE</code> <code>QREMOTE</code> <code>ensureQalias()</code> Alias queue <code>QUEUE</code> <code>QALIAS</code> <code>QALIAS</code> <code>ensureQmodel()</code> Model queue <code>QUEUE</code> <code>QMODEL</code> <code>QMODEL</code> <code>ensureChannel()</code> Channel <code>CHANNEL</code> <code>CHANNEL</code> <code>CHANNEL</code> <code>ensureAuthinfo()</code> Auth info <code>AUTHINFO</code> <code>AUTHINFO</code> <code>AUTHINFO</code> <code>ensureListener()</code> Listener <code>LISTENER</code> <code>LISTENER</code> <code>LISTENER</code> <code>ensureNamelist()</code> Namelist <code>NAMELIST</code> <code>NAMELIST</code> <code>NAMELIST</code> <code>ensureProcess()</code> Process <code>PROCESS</code> <code>PROCESS</code> <code>PROCESS</code> <code>ensureService()</code> Service <code>SERVICE</code> <code>SERVICE</code> <code>SERVICE</code> <code>ensureTopic()</code> Topic <code>TOPIC</code> <code>TOPIC</code> <code>TOPIC</code> <code>ensureSub()</code> Subscription <code>SUB</code> <code>SUB</code> <code>SUB</code> <code>ensureStgclass()</code> Storage class <code>STGCLASS</code> <code>STGCLASS</code> <code>STGCLASS</code> <code>ensureComminfo()</code> Comm info <code>COMMINFO</code> <code>COMMINFO</code> <code>COMMINFO</code> <code>ensureCfstruct()</code> CF structure <code>CFSTRUCT</code> <code>CFSTRUCT</code> <code>CFSTRUCT</code> <p>Most methods share the same signature:</p> <pre><code>EnsureResult ensureQlocal(String name, Map&lt;String, Object&gt; requestParameters);\n</code></pre> <p><code>responseParameters</code> is not exposed \u2014 the ensure logic always requests <code>[\"all\"]</code> internally so it can compare the full current state.</p>"},{"location":"ensure-methods/#queue-manager-singleton","title":"Queue manager (singleton)","text":"<p><code>ensureQmgr()</code> has no <code>name</code> parameter because the queue manager is a singleton that always exists. It can only return <code>UPDATED</code> or <code>UNCHANGED</code> (never <code>CREATED</code>):</p> <pre><code>EnsureResult ensureQmgr(Map&lt;String, Object&gt; requestParameters);\n</code></pre> <p>This makes it ideal for asserting queue manager-level settings such as statistics, monitoring, events, and logging attributes without corrupting <code>ALTDATE</code>/<code>ALTTIME</code> on every run.</p>"},{"location":"ensure-methods/#attribute-mapping","title":"Attribute mapping","text":"<p>The ensure methods participate in the same mapping pipeline as all other command methods. Pass <code>snake_case</code> attribute names in <code>requestParameters</code> and the mapping layer translates them to MQSC names for the DISPLAY, DEFINE, and ALTER commands automatically.</p>"},{"location":"ensure-methods/#configuration-management-example","title":"Configuration management example","text":"<p>The ensure pattern is designed for scripts that declare desired state:</p> <pre><code>void configureQueueManager(MqRestSession session) {\n    // Ensure queue manager settings\n    EnsureResult result = session.ensureQmgr(Map.of(\n        \"queue_statistics\", \"on\",\n        \"channel_statistics\", \"on\",\n        \"queue_monitoring\", \"medium\",\n        \"channel_monitoring\", \"medium\"\n    ));\n    System.out.println(\"Queue manager: \" + result.action());\n\n    // Ensure application queues\n    var queues = Map.of(\n        \"APP.REQUEST.Q\", Map.of(\"max_queue_depth\", 50000, \"default_persistence\", \"yes\"),\n        \"APP.REPLY.Q\", Map.of(\"max_queue_depth\", 10000, \"default_persistence\", \"no\"),\n        \"APP.DLQ\", Map.of(\"max_queue_depth\", 100000, \"default_persistence\", \"yes\")\n    );\n\n    for (var entry : queues.entrySet()) {\n        result = session.ensureQlocal(entry.getKey(), entry.getValue());\n        System.out.println(entry.getKey() + \": \" + result.action());\n    }\n}\n</code></pre> <p>Running this method repeatedly produces no side effects when the configuration is already correct. Only genuine changes trigger <code>ALTER</code> commands, keeping <code>ALTDATE</code>/<code>ALTTIME</code> accurate.</p>"},{"location":"examples/","title":"Examples","text":"<p>The <code>examples/</code> directory contains practical scripts that demonstrate common MQ administration tasks using <code>mq-rest-admin</code>. Each example is self-contained and can be run against the local Docker environment.</p>"},{"location":"examples/#prerequisites","title":"Prerequisites","text":"<p>Start the multi-queue-manager Docker environment and seed both queue managers:</p> <pre><code>./scripts/dev/mq_start.sh\n./scripts/dev/mq_seed.sh\n</code></pre> <p>This starts two queue managers (<code>QM1</code> on port 9453, <code>QM2</code> on port 9454) on a shared Docker network. See local MQ container for details.</p>"},{"location":"examples/#health-check","title":"Health check","text":"<p>Connect to one or more queue managers and check:</p> <ul> <li>Queue manager attributes via <code>displayQmgr()</code></li> <li>Running status via <code>displayQmstatus()</code></li> <li>Listener definitions via <code>displayListener()</code></li> </ul> <pre><code>var session = MqRestSession.builder()\n    .host(\"localhost\").port(9453).queueManager(\"QM1\")\n    .credentials(new LtpaAuth(\"mqadmin\", \"mqadmin\"))\n    .verifyTls(false)\n    .build();\n\nvar qmgr = session.displayQmgr();\nSystem.out.println(\"Queue manager: \" + qmgr.get(\"queue_manager_name\"));\n\nvar status = session.displayQmstatus();\nSystem.out.println(\"Status: \" + status.get(\"channel_initiator_status\"));\n\nvar listeners = session.displayListener(\"*\");\nfor (var listener : listeners) {\n    System.out.println(\"Listener: \" + listener.get(\"listener_name\")\n        + \" port=\" + listener.get(\"port\"));\n}\n</code></pre>"},{"location":"examples/#queue-depth-monitor","title":"Queue depth monitor","text":"<p>Display all local queues with their current depth and flag queues approaching capacity:</p> <pre><code>var queues = session.displayQueue(\"*\");\n\nfor (var queue : queues) {\n    var depth = ((Number) queue.get(\"current_queue_depth\")).intValue();\n    var maxDepth = ((Number) queue.get(\"max_queue_depth\")).intValue();\n    var pct = maxDepth &gt; 0 ? (depth * 100 / maxDepth) : 0;\n    var flag = pct &gt; 80 ? \" *** HIGH ***\" : \"\";\n    System.out.printf(\"%-40s %5d / %5d (%d%%)%s%n\",\n        queue.get(\"queue_name\"), depth, maxDepth, pct, flag);\n}\n</code></pre>"},{"location":"examples/#channel-status-report","title":"Channel status report","text":"<p>Cross-reference channel definitions with live channel status:</p> <pre><code>var channels = session.displayChannel(\"*\");\nvar statuses = session.displayChstatus(\"*\");\n\nvar runningChannels = statuses.stream()\n    .map(s -&gt; s.get(\"channel_name\"))\n    .collect(Collectors.toSet());\n\nfor (var channel : channels) {\n    var name = channel.get(\"channel_name\");\n    var state = runningChannels.contains(name) ? \"RUNNING\" : \"INACTIVE\";\n    System.out.println(name + \": \" + state);\n}\n</code></pre>"},{"location":"examples/#environment-provisioner","title":"Environment provisioner","text":"<p>Demonstrate bulk provisioning across two queue managers using ensure methods:</p> <pre><code>// Ensure application queues exist on QM1\nsession.ensureQlocal(\"APP.REQUESTS\", Map.of(\n    \"max_queue_depth\", 50000,\n    \"default_persistence\", \"persistent\"\n));\nsession.ensureQlocal(\"APP.RESPONSES\", Map.of(\n    \"max_queue_depth\", 50000,\n    \"default_persistence\", \"persistent\"\n));\n\n// Ensure listeners are running\nvar config = new SyncConfig(60, 1);\nsession.startListenerSync(\"TCP.LISTENER\", config);\n\nSystem.out.println(\"Environment provisioned\");\n</code></pre>"},{"location":"examples/#dead-letter-queue-inspector","title":"Dead letter queue inspector","text":"<p>Inspect the dead letter queue configuration:</p> <pre><code>var qmgr = session.displayQmgr();\nvar dlqName = (String) qmgr.get(\"dead_letter_q_name\");\n\nif (dlqName != null &amp;&amp; !dlqName.isBlank()) {\n    var dlq = session.displayQueue(dlqName);\n    if (!dlq.isEmpty()) {\n        var depth = dlq.get(0).get(\"current_queue_depth\");\n        var maxDepth = dlq.get(0).get(\"max_queue_depth\");\n        System.out.println(\"DLQ: \" + dlqName\n            + \" depth=\" + depth + \" max=\" + maxDepth);\n    }\n} else {\n    System.out.println(\"No dead letter queue configured\");\n}\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Java: 17 or later</li> <li>Maven: 3.9+ (or use the included Maven Wrapper <code>./mvnw</code>)</li> <li>IBM MQ: A running queue manager with the administrative REST API enabled</li> </ul>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>Add the dependency to your <code>pom.xml</code>:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.github.wphillipmoore&lt;/groupId&gt;\n    &lt;artifactId&gt;mq-rest-admin&lt;/artifactId&gt;\n    &lt;version&gt;0.1.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"getting-started/#creating-a-session","title":"Creating a session","text":"<p>All interaction with IBM MQ goes through an <code>MqRestSession</code>. You need the REST API host, port, queue manager name, and credentials:</p> <pre><code>import io.github.wphillipmoore.mq.rest.admin.MqRestSession;\nimport io.github.wphillipmoore.mq.rest.admin.auth.LtpaAuth;\n\nvar session = MqRestSession.builder()\n    .host(\"localhost\")\n    .port(9443)\n    .queueManager(\"QM1\")\n    .credentials(new LtpaAuth(\"mqadmin\", \"mqadmin\"))\n    .verifyTls(false)  // for local development only\n    .build();\n</code></pre>"},{"location":"getting-started/#running-a-command","title":"Running a command","text":"<p>Every MQSC command has a corresponding method on the session. Method names follow the pattern <code>verbQualifier</code> in camelCase:</p> <pre><code>// DISPLAY QUEUE \u2014 returns a list of maps\nList&lt;Map&lt;String, Object&gt;&gt; queues = session.displayQueue(\"SYSTEM.*\");\n\nfor (var queue : queues) {\n    System.out.println(queue.get(\"queue_name\") + \" \" + queue.get(\"current_queue_depth\"));\n}\n</code></pre> <pre><code>// DISPLAY QMGR \u2014 returns a single map or null\nMap&lt;String, Object&gt; qmgr = session.displayQmgr();\nif (qmgr != null) {\n    System.out.println(qmgr.get(\"queue_manager_name\"));\n}\n</code></pre>"},{"location":"getting-started/#attribute-mapping","title":"Attribute mapping","text":"<p>By default, the session maps between developer-friendly names and MQSC parameter names. This applies to both request and response attributes:</p> <pre><code>// With mapping enabled (default)\nvar queues = session.displayQueue(\"MY.QUEUE\",\n    Map.of(\"response_parameters\", List.of(\"current_queue_depth\", \"max_queue_depth\")));\n// Returns: [{\"queue_name\": \"MY.QUEUE\", \"current_queue_depth\": 0, \"max_queue_depth\": 5000}]\n\n// With mapping disabled\nvar queues = session.displayQueue(\"MY.QUEUE\",\n    Map.of(\"response_parameters\", List.of(\"CURDEPTH\", \"MAXDEPTH\")),\n    Map.of(\"mapAttributes\", false));\n// Returns: [{\"queue\": \"MY.QUEUE\", \"curdepth\": 0, \"maxdepth\": 5000}]\n</code></pre> <p>Mapping can be disabled at the session level:</p> <pre><code>var session = MqRestSession.builder()\n    .host(\"localhost\")\n    .port(9443)\n    .queueManager(\"QM1\")\n    .credentials(new LtpaAuth(\"mqadmin\", \"mqadmin\"))\n    .mapAttributes(false)\n    .build();\n</code></pre> <p>See Mapping Pipeline for a detailed explanation of how mapping works.</p>"},{"location":"getting-started/#strict-vs-lenient-mapping","title":"Strict vs lenient mapping","text":"<p>By default, mapping runs in strict mode. Unknown attribute names or values raise a <code>MappingException</code>. In lenient mode, unknown attributes pass through unchanged:</p> <pre><code>var session = MqRestSession.builder()\n    .host(\"localhost\")\n    .port(9443)\n    .queueManager(\"QM1\")\n    .credentials(new LtpaAuth(\"mqadmin\", \"mqadmin\"))\n    .mappingStrict(false)\n    .build();\n</code></pre>"},{"location":"getting-started/#custom-mapping-overrides","title":"Custom mapping overrides","text":"<p>Sites with existing naming conventions can override individual entries in the built-in mapping tables without replacing them entirely. Pass a <code>mappingOverrides</code> map when creating the session:</p> <pre><code>var session = MqRestSession.builder()\n    .host(\"localhost\")\n    .port(9443)\n    .queueManager(\"QM1\")\n    .credentials(new LtpaAuth(\"mqadmin\", \"mqadmin\"))\n    .mappingOverrides(Map.of(\n        \"qualifiers\", Map.of(\n            \"queue\", Map.of(\n                \"response_key_map\", Map.of(\n                    \"CURDEPTH\", \"queue_depth\",      // override built-in mapping\n                    \"MAXDEPTH\", \"queue_max_depth\"    // override built-in mapping\n                )\n            )\n        )\n    ))\n    .build();\n\nvar queues = session.displayQueue(\"MY.QUEUE\");\n// Returns: [{\"queue_depth\": 0, \"queue_max_depth\": 5000, ...}]\n</code></pre> <p>Overrides are sparse \u2014 you only specify the entries you want to change. All other mappings in the qualifier continue to work as normal. In the example above, only <code>CURDEPTH</code> and <code>MAXDEPTH</code> are remapped; every other queue attribute keeps its default name.</p> <p>Request-side mappings work the same way:</p> <pre><code>var session = MqRestSession.builder()\n    .host(\"localhost\")\n    .port(9443)\n    .queueManager(\"QM1\")\n    .credentials(new LtpaAuth(\"mqadmin\", \"mqadmin\"))\n    .verifyTls(false)\n    .mappingOverrides(Map.of(\n        \"qualifiers\", Map.of(\n            \"queue\", Map.of(\n                \"request_key_map\", Map.of(\n                    \"queue_depth\", \"CURDEPTH\"      // use your name on the request side\n                ),\n                \"response_key_map\", Map.of(\n                    \"CURDEPTH\", \"queue_depth\"      // and on the response side\n                )\n            )\n        )\n    ))\n    .build();\n\n// Now \"queue_depth\" works in WHERE filters, response_parameters, etc.\nvar queues = session.displayQueue(\"*\",\n    Map.of(\"where\", \"queue_depth GT 100\"));\n</code></pre> <p>Overrides support all five sub-maps per qualifier: <code>request_key_map</code>, <code>request_value_map</code>, <code>request_key_value_map</code>, <code>response_key_map</code>, and <code>response_value_map</code>. See Mapping Pipeline for details on how each sub-map is used.</p> <p>Invalid override structures raise exceptions at session construction time, so errors are caught early.</p>"},{"location":"getting-started/#gateway-queue-manager","title":"Gateway queue manager","text":"<p>The MQ REST API is available on all supported IBM MQ platforms (Linux, AIX, Windows, z/OS, and IBM i). mq-rest-admin is developed and tested against the Linux implementation only.</p> <p>In enterprise environments, a gateway queue manager can route MQSC commands to remote queue managers via MQ channels \u2014 the same mechanism used by <code>runmqsc -w</code> and the MQ Console.</p> <p>To route commands to a remote queue manager through a gateway, pass <code>gatewayQmgr</code> when creating the session. The <code>queueManager</code> parameter specifies the target (remote) queue manager, while <code>gatewayQmgr</code> names the local queue manager whose REST API routes the command:</p> <pre><code>// Route commands to QM2 through QM1's REST API\nvar session = MqRestSession.builder()\n    .host(\"qm1-host\")\n    .port(9443)\n    .queueManager(\"QM2\")           // target queue manager\n    .credentials(new LtpaAuth(\"mqadmin\", \"mqadmin\"))\n    .gatewayQmgr(\"QM1\")            // local gateway queue manager\n    .build();\n\nvar qmgr = session.displayQmgr();\n// Returns QM2's queue manager attributes, routed through QM1\n</code></pre> <p>Prerequisites:</p> <ul> <li>The gateway queue manager must have a running REST API.</li> <li>MQ channels must be configured between the gateway and target queue managers.</li> <li>A QM alias (QREMOTE with empty RNAME) must map the target QM name to the   correct transmission queue on the gateway.</li> </ul>"},{"location":"getting-started/#error-handling","title":"Error handling","text":"<p><code>DISPLAY</code> commands return an empty list when no objects match. Queue manager display methods return <code>null</code> when no match is found. Non-display commands raise <code>MqRestCommandException</code> on failure:</p> <pre><code>import io.github.wphillipmoore.mq.rest.admin.exception.MqRestCommandException;\n\n// Empty list \u2014 no exception\nList&lt;Map&lt;String, Object&gt;&gt; result = session.displayQueue(\"NONEXISTENT.*\");\nassert result.isEmpty();\n\n// Define raises on error\ntry {\n    session.defineQlocal(\"MY.QUEUE\", Map.of());\n} catch (MqRestCommandException e) {\n    System.out.println(e.getMessage());\n    System.out.println(\"HTTP status: \" + e.getStatusCode());\n    System.out.println(e.getPayload());  // full MQ response payload\n}\n</code></pre>"},{"location":"getting-started/#diagnostic-state","title":"Diagnostic state","text":"<p>The session retains the most recent request and response for inspection:</p> <pre><code>session.displayQueue(\"MY.QUEUE\");\n\nSystem.out.println(session.getLastCommandPayload());    // the JSON sent to MQ\nSystem.out.println(session.getLastResponsePayload());   // the parsed JSON response\nSystem.out.println(session.getLastHttpStatus());        // HTTP status code\nSystem.out.println(session.getLastResponseText());      // raw response body\n</code></pre>"},{"location":"javadoc/","title":"Javadoc","text":"<p>The generated Javadoc API documentation is available at /javadoc/.</p> <p>Javadoc is generated from source comments using the <code>maven-javadoc-plugin</code>:</p> <pre><code>./mvnw javadoc:javadoc\n</code></pre> <p>The generated output is placed alongside the MkDocs site at <code>docs/site/site/javadoc/</code> so both are served from the same GitHub Pages deployment.</p>"},{"location":"mapping-pipeline/","title":"Mapping Pipeline","text":""},{"location":"mapping-pipeline/#the-three-namespace-problem","title":"The three-namespace problem","text":"<p>IBM MQ uses multiple naming conventions depending on the interface:</p> <p>MQSC names (e.g. <code>CURDEPTH</code>, <code>DEFPSIST</code>) : Short, uppercase tokens used in MQSC commands and the REST API's   <code>runCommandJSON</code> endpoint.</p> <p>PCF names (e.g. <code>CurrentQDepth</code>, <code>DefPersistence</code>) : CamelCase names from the Programmable Command Formats. Not used   directly by mq-rest-admin, but they form the intermediate namespace in   the mapping pipeline.</p> <p>Developer names (e.g. <code>current_queue_depth</code>, <code>default_persistence</code>) : Human-readable <code>snake_case</code> names for use in application code.</p> <p>The mapping pipeline translates between MQSC and developer names. PCF names were used as an intermediate reference during the original extraction process that bootstrapped the mapping tables but do not appear at runtime.</p> <p>In Java, developer-friendly names use <code>snake_case</code> (e.g. <code>current_queue_depth</code>, <code>default_persistence</code>), matching the convention across the mq-rest-admin library family. The mapping tables are loaded from a JSON resource file and are identical across language implementations.</p> <pre><code>// With mapping enabled (default) \u2014 developer-friendly names\nvar queues = session.displayQueue(\"MY.QUEUE\",\n    Map.of(\"response_parameters\", List.of(\"current_queue_depth\", \"max_queue_depth\")));\n// Returns: [{\"queue_name\": \"MY.QUEUE\", \"current_queue_depth\": 0, \"max_queue_depth\": 5000}]\n\n// With mapping disabled \u2014 native MQSC names\nvar queues = session.displayQueue(\"MY.QUEUE\",\n    Map.of(\"response_parameters\", List.of(\"CURDEPTH\", \"MAXDEPTH\")),\n    Map.of(\"mapAttributes\", false));\n// Returns: [{\"queue\": \"MY.QUEUE\", \"curdepth\": 0, \"maxdepth\": 5000}]\n</code></pre>"},{"location":"mapping-pipeline/#qualifier-based-mapping","title":"Qualifier-based mapping","text":"<p>Mappings are organized by qualifier (e.g. <code>queue</code>, <code>channel</code>, <code>qmgr</code>), not by command. A single qualifier's mapping tables serve all commands that operate on that object type. For example, the <code>queue</code> qualifier covers <code>DISPLAY QUEUE</code>, <code>DEFINE QLOCAL</code>, <code>DELETE QALIAS</code>, and all other queue-related commands.</p> <p>This design avoids duplicating mapping data across commands and reflects how MQSC attributes are shared across command verbs.</p> <p>See the Qualifier Mapping Reference for the complete per-qualifier documentation, including every key map, value map, and key-value map entry.</p>"},{"location":"mapping-pipeline/#request-mapping-flow","title":"Request mapping flow","text":"<p>When mapping is enabled, request attributes are translated before sending to the MQ REST API:</p> <ol> <li> <p>Key mapping: Each <code>snake_case</code> attribute name is looked up in the    qualifier's <code>request_key_map</code>. If found, the key is replaced with the    MQSC parameter name.</p> </li> <li> <p>Value mapping: For attributes with enumerated values, the    qualifier's <code>request_value_map</code> translates developer values to MQSC    values (e.g. <code>\"yes\"</code> \u2192 <code>\"YES\"</code>).</p> </li> <li> <p>Key-value mapping: Some attributes require both key and value to    change simultaneously. The <code>request_key_value_map</code> handles cases    where a single developer attribute expands to a different MQSC key+value    pair (e.g. <code>channel_type=\"server_connection\"</code> \u2192    <code>CHLTYPE(\"SVRCONN\")</code>).</p> </li> </ol>"},{"location":"mapping-pipeline/#java-example","title":"Java example","text":"<pre><code>// Developer-friendly request parameters\nsession.defineQlocal(\"MY.QUEUE\", Map.of(\n    \"max_queue_depth\", 50000,\n    \"default_persistence\", \"yes\",\n    \"description\", \"Application queue\"\n));\n\n// After request mapping, the JSON payload sent to MQ contains:\n// { \"MAXDEPTH\": 50000, \"DEFPSIST\": \"YES\", \"DESCR\": \"Application queue\" }\n</code></pre>"},{"location":"mapping-pipeline/#response-mapping-flow","title":"Response mapping flow","text":"<p>Response attributes are translated after receiving the MQ REST response:</p> <ol> <li> <p>Key mapping: Each MQSC parameter name from the response is looked    up in the qualifier's <code>response_key_map</code>. If found, the key is    replaced with the <code>snake_case</code> name.</p> </li> <li> <p>Value mapping: Enumerated MQSC values are translated to    developer-friendly values via the <code>response_value_map</code> (e.g. <code>\"YES\"</code> \u2192    <code>\"yes\"</code>).</p> </li> </ol>"},{"location":"mapping-pipeline/#java-example_1","title":"Java example","text":"<pre><code>// Request specific response attributes using developer-friendly names\nvar queues = session.displayQueue(\"MY.QUEUE\",\n    Map.of(\"response_parameters\", List.of(\"current_queue_depth\", \"max_queue_depth\")));\n\n// MQ returns MQSC names in the response:\n// { \"queue\": \"MY.QUEUE\", \"curdepth\": 0, \"maxdepth\": 5000 }\n\n// After response mapping, the caller receives developer-friendly names:\n// { \"queue_name\": \"MY.QUEUE\", \"current_queue_depth\": 0, \"max_queue_depth\": 5000 }\n</code></pre>"},{"location":"mapping-pipeline/#response-parameter-mapping","title":"Response parameter mapping","text":"<p>When the caller specifies <code>response_parameters</code> (the list of attributes to return), those names are also mapped from <code>snake_case</code> to MQSC before being sent in the request. This allows callers to request specific attributes using developer-friendly names.</p> <p>Response parameter macros (like <code>CFCONLOS</code> for channel status) are recognized and passed through without mapping.</p>"},{"location":"mapping-pipeline/#where-keyword-mapping","title":"WHERE keyword mapping","text":"<p>The <code>where</code> parameter on DISPLAY methods accepts a filter expression like <code>\"current_queue_depth GT 100\"</code>. The first token (the keyword) is mapped from <code>snake_case</code> to the MQSC name. The rest of the expression is passed through unchanged.</p>"},{"location":"mapping-pipeline/#qualifier-resolution","title":"Qualifier resolution","text":"<p>When a command is executed, the mapping qualifier is resolved by:</p> <ol> <li>Looking up the command key (e.g. <code>\"DISPLAY QUEUE\"</code>) in    <code>MAPPING_DATA[\"commands\"]</code> for an explicit qualifier.</li> <li>Falling back to a hardcoded default map (e.g. <code>QLOCAL</code> \u2192 <code>queue</code>,    <code>CHANNEL</code> \u2192 <code>channel</code>).</li> <li>As a last resort, lowercasing the MQSC qualifier.</li> </ol> <p>This means <code>DEFINE QLOCAL</code>, <code>DEFINE QREMOTE</code>, and <code>DISPLAY QUEUE</code> all resolve to the <code>queue</code> qualifier and share the same mapping tables.</p>"},{"location":"mapping-pipeline/#strict-vs-lenient-mode","title":"Strict vs lenient mode","text":"<p>Strict mode (default): Any attribute name or value that cannot be mapped raises a <code>MappingException</code>. This catches typos and unsupported attributes early.</p> <p>Lenient mode (<code>mappingStrict(false)</code>): Unknown attribute names and values pass through unchanged. This is useful when working with attributes not yet covered by the mapping tables.</p> <p>The mode is set at session construction and applies to all mapping operations. It cannot be overridden per-call.</p> <p>In Java, the mode is set via the builder:</p> <pre><code>// Strict mode (default) \u2014 throws MappingException on unknown attributes\nvar session = MqRestSession.builder()\n    .host(\"localhost\")\n    .port(9443)\n    .queueManager(\"QM1\")\n    .credentials(new LtpaAuth(\"admin\", \"passw0rd\"))\n    .mappingStrict(true)  // default\n    .build();\n\n// Lenient mode \u2014 unknown attributes pass through unchanged\nvar session = MqRestSession.builder()\n    .host(\"localhost\")\n    .port(9443)\n    .queueManager(\"QM1\")\n    .credentials(new LtpaAuth(\"admin\", \"passw0rd\"))\n    .mappingStrict(false)\n    .build();\n</code></pre>"},{"location":"mapping-pipeline/#custom-mapping-overrides","title":"Custom mapping overrides","text":"<p>The built-in mapping tables cover all standard MQSC attributes, but sites may use different <code>snake_case</code> conventions. The <code>mappingOverrides</code> parameter on <code>MqRestSession</code> lets you layer sparse changes on top of the built-in data without replacing it.</p>"},{"location":"mapping-pipeline/#how-merging-works","title":"How merging works","text":"<p>Overrides are merged at the key level within each sub-map. You only specify the entries you want to change \u2014 all other mappings remain intact:</p> <pre><code>var overrides = Map.of(\n    \"qualifiers\", Map.of(\n        \"queue\", Map.of(\n            \"response_key_map\", Map.of(\n                \"CURDEPTH\", \"queue_depth\",      // override built-in mapping\n                \"MAXDEPTH\", \"queue_max_depth\"    // override built-in mapping\n            )\n        )\n    )\n);\n\nvar session = MqRestSession.builder()\n    .host(\"localhost\")\n    .port(9443)\n    .queueManager(\"QM1\")\n    .credentials(new LtpaAuth(\"admin\", \"passw0rd\"))\n    .mappingOverrides(overrides)\n    .build();\n\nvar queues = session.displayQueue(\"MY.QUEUE\");\n// Returns: [{\"queue_depth\": 0, \"queue_max_depth\": 5000, ...}]\n// All other queue attributes keep their default names\n</code></pre> <p>When this override is applied:</p> <ol> <li>The built-in <code>MAPPING_DATA</code> is deep-copied (the original is never mutated).</li> <li>The <code>queue</code> qualifier's <code>response_key_map</code> is updated: the entry for    <code>CURDEPTH</code> changes from <code>\"current_queue_depth\"</code> to <code>\"queue_depth\"</code>.</li> <li>All other entries in <code>response_key_map</code> (and all other sub-maps) remain    unchanged.</li> </ol>"},{"location":"mapping-pipeline/#supported-override-keys","title":"Supported override keys","text":"<p>The top level of <code>mappingOverrides</code> accepts two keys:</p> <ul> <li><code>commands</code>: Override command-level metadata (e.g. which qualifier a   command resolves to). Each command entry is shallow-merged.</li> <li><code>qualifiers</code>: Override qualifier mapping tables. Each qualifier supports   five sub-maps:</li> <li><code>request_key_map</code> \u2014 <code>snake_case</code> \u2192 MQSC key mapping for requests</li> <li><code>request_value_map</code> \u2014 value translations for request attributes</li> <li><code>request_key_value_map</code> \u2014 combined key+value translations for requests</li> <li><code>response_key_map</code> \u2014 MQSC \u2192 <code>snake_case</code> key mapping for responses</li> <li><code>response_value_map</code> \u2014 value translations for response attributes</li> </ul>"},{"location":"mapping-pipeline/#adding-new-qualifiers","title":"Adding new qualifiers","text":"<p>You can add mappings for qualifiers not yet covered by the built-in data:</p> <pre><code>var overrides = Map.of(\n    \"qualifiers\", Map.of(\n        \"custom_object\", Map.of(\n            \"request_key_map\", Map.of(\"my_attr\", \"MYATTR\"),\n            \"response_key_map\", Map.of(\"MYATTR\", \"my_attr\"),\n            \"request_value_map\", Map.of(),\n            \"response_value_map\", Map.of()\n        )\n    )\n);\n</code></pre>"},{"location":"mapping-pipeline/#validation","title":"Validation","text":"<p>The override structure is validated at session construction time. Invalid shapes raise exceptions immediately, so errors are caught before any commands are sent.</p>"},{"location":"mapping-pipeline/#per-call-opt-out","title":"Per-call opt-out","text":"<p>Mapping can be disabled for a single command invocation without changing the session-level setting:</p> <pre><code>// Session has mapping enabled (default)\nvar session = MqRestSession.builder()\n    .host(\"localhost\").port(9443).queueManager(\"QM1\")\n    .credentials(new LtpaAuth(\"admin\", \"passw0rd\"))\n    .build();\n\n// This call uses native MQSC names\nvar queues = session.displayQueue(\"MY.QUEUE\",\n    Map.of(\"response_parameters\", List.of(\"CURDEPTH\", \"MAXDEPTH\")),\n    Map.of(\"mapAttributes\", false));\n\n// Returns native MQSC names: [{\"queue\": \"MY.QUEUE\", \"curdepth\": 0, ...}]\n</code></pre> <p>Mapping can also be disabled entirely at the session level:</p> <pre><code>var session = MqRestSession.builder()\n    .host(\"localhost\").port(9443).queueManager(\"QM1\")\n    .credentials(new LtpaAuth(\"admin\", \"passw0rd\"))\n    .mapAttributes(false)  // all commands use native MQSC names\n    .build();\n</code></pre>"},{"location":"sync-methods/","title":"Synchronous Start/Stop/Restart","text":""},{"location":"sync-methods/#the-problem-with-fire-and-forget","title":"The problem with fire-and-forget","text":"<p>All MQSC <code>START</code> and <code>STOP</code> commands are fire-and-forget \u2014 they return immediately without waiting for the object to reach its target state. In practice, tooling that provisions infrastructure needs to wait until a channel is <code>RUNNING</code> or a listener is <code>STOPPED</code> before proceeding to the next step. Writing polling loops by hand is error-prone and clutters business logic with retry mechanics.</p>"},{"location":"sync-methods/#the-sync-pattern","title":"The sync pattern","text":"<p>The <code>*Sync</code> and <code>restart*</code> methods wrap the fire-and-forget commands with a polling loop that issues <code>DISPLAY *STATUS</code> until the object reaches a stable state or the timeout expires.</p> <p>Each call returns a <code>SyncResult</code> describing what happened:</p> <pre><code>import io.github.wphillipmoore.mq.rest.admin.sync.SyncConfig;\nimport io.github.wphillipmoore.mq.rest.admin.sync.SyncOperation;\nimport io.github.wphillipmoore.mq.rest.admin.sync.SyncResult;\n\n// SyncOperation enum values:\n//   STARTED   \u2014 Object confirmed running\n//   STOPPED   \u2014 Object confirmed stopped\n//   RESTARTED \u2014 Stop-then-start completed\n\n// SyncResult record:\n//   operation()      \u2014 the SyncOperation performed\n//   polls()          \u2014 number of status polls issued\n//   elapsedSeconds() \u2014 wall-clock time from command to confirmation\n</code></pre> <p>Polling is controlled by a <code>SyncConfig</code> record:</p> <pre><code>// SyncConfig record:\n//   timeoutSeconds (default 30)     \u2014 max wait before raising\n//   pollIntervalSeconds (default 1) \u2014 seconds between polls\n</code></pre> <p>If the object does not reach the target state within the timeout, <code>MqRestTimeoutException</code> is raised.</p>"},{"location":"sync-methods/#basic-usage","title":"Basic usage","text":"<pre><code>// Start a channel and wait until it is RUNNING\nSyncResult result = session.startChannelSync(\"TO.PARTNER\");\nassert result.operation() == SyncOperation.STARTED;\nSystem.out.println(\"Channel running after \" + result.polls() + \" poll(s), \"\n    + result.elapsedSeconds() + \"s\");\n\n// Stop a listener and wait until it is STOPPED\nresult = session.stopListenerSync(\"TCP.LISTENER\");\nassert result.operation() == SyncOperation.STOPPED;\n</code></pre>"},{"location":"sync-methods/#restart-convenience","title":"Restart convenience","text":"<p>The <code>restart*</code> methods perform a synchronous stop followed by a synchronous start. Each phase gets the full timeout independently \u2014 worst case is 2x the configured timeout.</p> <p>The returned <code>SyncResult</code> reports total polls and total elapsed time across both phases:</p> <pre><code>SyncResult result = session.restartChannel(\"TO.PARTNER\");\nassert result.operation() == SyncOperation.RESTARTED;\nSystem.out.println(\"Restarted in \" + result.elapsedSeconds() + \"s (\"\n    + result.polls() + \" total polls)\");\n</code></pre>"},{"location":"sync-methods/#custom-timeout-and-poll-interval","title":"Custom timeout and poll interval","text":"<p>Pass a <code>SyncConfig</code> to override the defaults:</p> <pre><code>// Aggressive polling for fast local development\nSyncConfig fast = new SyncConfig(10, 0.25);\nSyncResult result = session.startServiceSync(\"MY.SVC\", fast);\n\n// Patient polling for remote queue managers\nSyncConfig patient = new SyncConfig(120, 5);\nresult = session.startChannelSync(\"REMOTE.CHL\", patient);\n</code></pre>"},{"location":"sync-methods/#timeout-handling","title":"Timeout handling","text":"<p>When the timeout expires, <code>MqRestTimeoutException</code> is raised with diagnostic attributes:</p> <pre><code>import io.github.wphillipmoore.mq.rest.admin.exception.MqRestTimeoutException;\n\ntry {\n    session.startChannelSync(\n        \"BROKEN.CHL\",\n        new SyncConfig(15, 1)\n    );\n} catch (MqRestTimeoutException e) {\n    System.out.println(\"Object:    \" + e.getName());\n    System.out.println(\"Operation: \" + e.getOperation());\n    System.out.println(\"Elapsed:   \" + e.getElapsed() + \"s\");\n    System.out.println(\"Detail:    \" + e.getMessage());\n}\n</code></pre> <p><code>MqRestTimeoutException</code> extends <code>MqRestException</code>, so existing <code>catch (MqRestException e)</code> handlers will catch it.</p>"},{"location":"sync-methods/#available-methods","title":"Available methods","text":"Method Operation START/STOP qualifier Status qualifier <code>startChannelSync()</code> Start <code>CHANNEL</code> <code>CHSTATUS</code> <code>stopChannelSync()</code> Stop <code>CHANNEL</code> <code>CHSTATUS</code> <code>restartChannel()</code> Restart <code>CHANNEL</code> <code>CHSTATUS</code> <code>startListenerSync()</code> Start <code>LISTENER</code> <code>LSSTATUS</code> <code>stopListenerSync()</code> Stop <code>LISTENER</code> <code>LSSTATUS</code> <code>restartListener()</code> Restart <code>LISTENER</code> <code>LSSTATUS</code> <code>startServiceSync()</code> Start <code>SERVICE</code> <code>SVSTATUS</code> <code>stopServiceSync()</code> Stop <code>SERVICE</code> <code>SVSTATUS</code> <code>restartService()</code> Restart <code>SERVICE</code> <code>SVSTATUS</code> <p>All methods share the same signature pattern:</p> <pre><code>SyncResult startChannelSync(String name);\nSyncResult startChannelSync(String name, SyncConfig config);\n</code></pre> <p>The <code>config</code> parameter is optional \u2014 when omitted, the default <code>SyncConfig</code> (30-second timeout, 1-second poll interval) is used.</p>"},{"location":"sync-methods/#status-detection","title":"Status detection","text":"<p>The polling loop checks the <code>STATUS</code> attribute in the <code>DISPLAY *STATUS</code> response. The target values are:</p> <ul> <li>Start: <code>RUNNING</code></li> <li>Stop: <code>STOPPED</code></li> </ul>"},{"location":"sync-methods/#channel-stop-edge-case","title":"Channel stop edge case","text":"<p>When a channel stops, its <code>CHSTATUS</code> record may disappear entirely (the <code>DISPLAY CHSTATUS</code> response returns no rows). The channel sync methods treat an empty status result as successfully stopped. Listener and service status records are always present, so empty results are not treated as stopped for those object types.</p>"},{"location":"sync-methods/#attribute-mapping","title":"Attribute mapping","text":"<p>The sync methods call the internal MQSC command layer, so they participate in the same mapping pipeline as all other command methods. The status key is checked using both the mapped <code>snake_case</code> name and the raw MQSC name, so polling works correctly regardless of whether mapping is enabled or disabled.</p>"},{"location":"sync-methods/#provisioning-example","title":"Provisioning example","text":"<p>The sync methods pair naturally with the ensure methods for end-to-end provisioning:</p> <pre><code>SyncConfig config = new SyncConfig(60, 1);\n\n// Ensure listeners exist for application and admin traffic\nsession.ensureListener(\"APP.LISTENER\", Map.of(\n    \"transport_type\", \"TCP\",\n    \"port\", 1415,\n    \"start_mode\", \"MQSVC_CONTROL_Q_MGR\"\n));\nsession.ensureListener(\"ADMIN.LISTENER\", Map.of(\n    \"transport_type\", \"TCP\",\n    \"port\", 1416,\n    \"start_mode\", \"MQSVC_CONTROL_Q_MGR\"\n));\n\n// Start them synchronously\nsession.startListenerSync(\"APP.LISTENER\", config);\nsession.startListenerSync(\"ADMIN.LISTENER\", config);\n\nSystem.out.println(\"Listeners ready\");\n</code></pre>"},{"location":"sync-methods/#rolling-restart-example","title":"Rolling restart example","text":"<p>Restart all listeners with error handling \u2014 useful when a queue manager serves multiple TCP ports for different client populations:</p> <pre><code>import io.github.wphillipmoore.mq.rest.admin.exception.MqRestTimeoutException;\n\nvar listeners = List.of(\"APP.LISTENER\", \"ADMIN.LISTENER\", \"PARTNER.LISTENER\");\nvar config = new SyncConfig(30, 2);\n\nfor (var name : listeners) {\n    try {\n        SyncResult result = session.restartListener(name, config);\n        System.out.println(name + \": restarted in \" + result.elapsedSeconds() + \"s\");\n    } catch (MqRestTimeoutException e) {\n        System.out.println(name + \": timed out \u2014 \" + e.getMessage());\n    }\n}\n</code></pre>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#core","title":"Core","text":"<ul> <li>Session \u2014 <code>MqRestSession</code> main entry point</li> <li>Commands \u2014 MQSC command methods</li> <li>Transport \u2014 <code>MqRestTransport</code> and <code>HttpClientTransport</code></li> </ul>"},{"location":"api/#authentication","title":"Authentication","text":"<ul> <li>Auth \u2014 <code>Credentials</code> sealed interface and implementations</li> </ul>"},{"location":"api/#mapping","title":"Mapping","text":"<ul> <li>Mapping \u2014 <code>AttributeMapper</code>, <code>MappingData</code>, <code>MappingOverrideMode</code></li> </ul>"},{"location":"api/#exceptions","title":"Exceptions","text":"<ul> <li>Exceptions \u2014 <code>MqRestException</code> hierarchy</li> </ul>"},{"location":"api/#patterns","title":"Patterns","text":"<ul> <li>Ensure \u2014 <code>EnsureResult</code>, <code>EnsureAction</code></li> <li>Sync \u2014 <code>SyncConfig</code>, <code>SyncResult</code>, <code>SyncOperation</code></li> </ul>"},{"location":"api/auth/","title":"Authentication","text":""},{"location":"api/auth/#overview","title":"Overview","text":"<p>The authentication module provides credential types for the three authentication modes supported by the IBM MQ REST API: mutual TLS (mTLS) client certificates, LTPA token, and HTTP Basic.</p> <p>Pass a credential object to <code>MqRestSession.builder()</code> via the <code>credentials()</code> method. Always use TLS (<code>https://</code>) for production deployments to protect credentials and data in transit.</p> <pre><code>import io.github.wphillipmoore.mq.rest.admin.MqRestSession;\nimport io.github.wphillipmoore.mq.rest.admin.auth.*;\n\n// mTLS client certificate auth \u2014 strongest; no shared secrets\nvar session = MqRestSession.builder()\n    .host(\"mq-host\").port(9443).queueManager(\"QM1\")\n    .credentials(new CertificateAuth(\"/path/to/cert.pem\", \"/path/to/key.pem\"))\n    .build();\n\n// LTPA token auth \u2014 credentials sent once at login, then cookie-based\nvar session = MqRestSession.builder()\n    .host(\"mq-host\").port(9443).queueManager(\"QM1\")\n    .credentials(new LtpaAuth(\"user\", \"pass\"))\n    .build();\n\n// Basic auth \u2014 credentials sent with every request\nvar session = MqRestSession.builder()\n    .host(\"mq-host\").port(9443).queueManager(\"QM1\")\n    .credentials(new BasicAuth(\"user\", \"pass\"))\n    .build();\n</code></pre>"},{"location":"api/auth/#credentials","title":"Credentials","text":"<p><code>Credentials</code> is a sealed interface representing authentication credentials for the MQ REST API:</p> <pre><code>public sealed interface Credentials\n    permits BasicAuth, LtpaAuth, CertificateAuth {}\n</code></pre>"},{"location":"api/auth/#certificateauth","title":"CertificateAuth","text":"<p>Client certificate authentication via TLS mutual authentication (mTLS). This is the strongest authentication mode \u2014 no shared secrets cross the wire.</p> <pre><code>public record CertificateAuth(\n    String certPath,   // path to client certificate file\n    String keyPath     // path to private key file (nullable if combined)\n) implements Credentials {}\n</code></pre> <pre><code>// Separate certificate and key files\nvar creds = new CertificateAuth(\"/path/to/cert.pem\", \"/path/to/key.pem\");\n\n// Combined cert+key file\nvar creds = new CertificateAuth(\"/path/to/combined.pem\");\n</code></pre> <p>No <code>Authorization</code> header is sent; authentication is handled at the TLS layer via the <code>SSLContext</code> configured on the transport.</p>"},{"location":"api/auth/#ltpaauth","title":"LtpaAuth","text":"<p>LTPA token-based authentication. Credentials are sent once during a <code>/login</code> request at session construction; subsequent API calls carry only the LTPA cookie.</p> <pre><code>public record LtpaAuth(\n    String username,\n    String password\n) implements Credentials {}\n</code></pre> <pre><code>var creds = new LtpaAuth(\"mqadmin\", \"passw0rd\");\n</code></pre> <p>The session performs the login automatically at build time and extracts the <code>LtpaToken2</code> cookie for subsequent requests.</p>"},{"location":"api/auth/#basicauth","title":"BasicAuth","text":"<p>HTTP Basic authentication. The <code>Authorization</code> header is constructed from the username and password and sent with every request.</p> <pre><code>public record BasicAuth(\n    String username,\n    String password\n) implements Credentials {}\n</code></pre> <pre><code>var creds = new BasicAuth(\"mqadmin\", \"passw0rd\");\n</code></pre> <p>Note</p> <p>All examples and documentation in this project use LTPA as the default authentication method. If you see <code>new LtpaAuth(...)</code> in an example, you can substitute <code>new BasicAuth(...)</code> or <code>new CertificateAuth(...)</code> based on your environment.</p>"},{"location":"api/auth/#choosing-between-ltpa-and-basic-authentication","title":"Choosing between LTPA and Basic authentication","text":"<p>Both LTPA and Basic authentication use a username and password. The key difference is how often those credentials cross the wire.</p> <p>LTPA is the recommended choice for username/password authentication. Credentials are sent once during the <code>/login</code> request; subsequent API calls carry only the LTPA cookie. This reduces credential exposure and is more efficient for sessions that issue many commands.</p> <p>Use Basic authentication as a fallback when:</p> <ul> <li>The mqweb configuration does not enable the <code>/login</code> endpoint (for example,   minimal container images that only expose the REST API).</li> <li>A reverse proxy or API gateway handles authentication and forwards a Basic   auth header; cookie-based flows may not survive the proxy.</li> <li>Single-command scripts where the login round-trip doubles the request count   for no security benefit.</li> <li>Long-running sessions where LTPA token expiry (typically two hours) could   cause mid-operation failures; the library does not currently re-authenticate   automatically.</li> <li>Local development or CI against a <code>localhost</code> container, where transport   security is not a concern.</li> </ul>"},{"location":"api/commands/","title":"Command Methods","text":""},{"location":"api/commands/#overview","title":"Overview","text":"<p><code>MqRestSession</code> provides ~144 generated command methods, one for each MQSC command verb + qualifier combination. Each method is a thin wrapper that calls the internal command dispatcher with the correct verb and qualifier. Method names follow the pattern <code>verbQualifier</code> in camelCase, mapping directly to MQSC commands (e.g. <code>DISPLAY QUEUE</code> becomes <code>displayQueue()</code>).</p>"},{"location":"api/commands/#method-signature-pattern","title":"Method signature pattern","text":"<pre><code>// DISPLAY commands return a list\nList&lt;Map&lt;String, Object&gt;&gt; displayQueue(String name);\nList&lt;Map&lt;String, Object&gt;&gt; displayQueue(String name, Map&lt;String, Object&gt; params);\nList&lt;Map&lt;String, Object&gt;&gt; displayQueue(\n    String name, Map&lt;String, Object&gt; params,\n    List&lt;String&gt; responseParameters, String where);\n\n// Non-DISPLAY commands return void\nvoid defineQlocal(String name, Map&lt;String, Object&gt; params);\nvoid alterChannel(String name, Map&lt;String, Object&gt; params);\nvoid deleteQlocal(String name);\n\n// Queue manager singletons return a single map\nMap&lt;String, Object&gt; displayQmgr();\nMap&lt;String, Object&gt; displayQmgr(Map&lt;String, Object&gt; params, List&lt;String&gt; responseParameters);\nMap&lt;String, Object&gt; displayQmstatus();\n</code></pre>"},{"location":"api/commands/#parameters","title":"Parameters","text":"<p>All methods accept these optional parameters:</p> Parameter Description <code>name</code> Object name or wildcard pattern (e.g. <code>\"MY.QUEUE\"</code>, <code>\"APP.*\"</code>). Required for most non-QMGR commands. <code>params</code> Request attributes as key-value pairs. Mapped from <code>snake_case</code> when mapping is enabled. <code>responseParameters</code> List of attribute names to include in the response. Defaults to <code>[\"all\"]</code>. <code>where</code> Filter expression for DISPLAY commands (e.g. <code>\"current_queue_depth GT 100\"</code>). The keyword is mapped from <code>snake_case</code> when mapping is enabled."},{"location":"api/commands/#return-values","title":"Return values","text":"<ul> <li>DISPLAY commands: <code>List&lt;Map&lt;String, Object&gt;&gt;</code> \u2014 one map per matched object.   An empty list means no objects matched (not an error).</li> <li>Queue manager singletons (<code>displayQmgr</code>, <code>displayQmstatus</code>,   <code>displayCmdserv</code>): <code>Map&lt;String, Object&gt;</code> or <code>null</code>.</li> <li>Non-DISPLAY commands: <code>void</code> on success; throws <code>MqRestCommandException</code>   on failure.</li> </ul>"},{"location":"api/commands/#display-methods","title":"DISPLAY methods","text":"Method MQSC command Qualifier mapping <code>displayApstatus()</code> <code>DISPLAY APSTATUS</code> apstatus <code>displayArchive()</code> <code>DISPLAY ARCHIVE</code> archive <code>displayAuthinfo()</code> <code>DISPLAY AUTHINFO</code> authinfo <code>displayAuthrec()</code> <code>DISPLAY AUTHREC</code> authrec <code>displayAuthserv()</code> <code>DISPLAY AUTHSERV</code> authserv <code>displayCfstatus()</code> <code>DISPLAY CFSTATUS</code> cfstatus <code>displayCfstruct()</code> <code>DISPLAY CFSTRUCT</code> cfstruct <code>displayChannel()</code> <code>DISPLAY CHANNEL</code> channel <code>displayChinit()</code> <code>DISPLAY CHINIT</code> chinit <code>displayChlauth()</code> <code>DISPLAY CHLAUTH</code> chlauth <code>displayChstatus()</code> <code>DISPLAY CHSTATUS</code> chstatus <code>displayClusqmgr()</code> <code>DISPLAY CLUSQMGR</code> clusqmgr <code>displayCmdserv()</code> <code>DISPLAY CMDSERV</code> cmdserv <code>displayComminfo()</code> <code>DISPLAY COMMINFO</code> comminfo <code>displayConn()</code> <code>DISPLAY CONN</code> conn <code>displayEntauth()</code> <code>DISPLAY ENTAUTH</code> entauth <code>displayGroup()</code> <code>DISPLAY GROUP</code> group <code>displayListener()</code> <code>DISPLAY LISTENER</code> listener <code>displayLog()</code> <code>DISPLAY LOG</code> log <code>displayLsstatus()</code> <code>DISPLAY LSSTATUS</code> lsstatus <code>displayMaxsmsgs()</code> <code>DISPLAY MAXSMSGS</code> maxsmsgs <code>displayNamelist()</code> <code>DISPLAY NAMELIST</code> namelist <code>displayPolicy()</code> <code>DISPLAY POLICY</code> policy <code>displayProcess()</code> <code>DISPLAY PROCESS</code> process <code>displayPubsub()</code> <code>DISPLAY PUBSUB</code> pubsub <code>displayQmgr()</code> <code>DISPLAY QMGR</code> qmgr <code>displayQmstatus()</code> <code>DISPLAY QMSTATUS</code> qmgr <code>displayQstatus()</code> <code>DISPLAY QSTATUS</code> queue <code>displayQueue()</code> <code>DISPLAY QUEUE</code> queue <code>displaySbstatus()</code> <code>DISPLAY SBSTATUS</code> sbstatus <code>displaySecurity()</code> <code>DISPLAY SECURITY</code> security <code>displayService()</code> <code>DISPLAY SERVICE</code> service <code>displaySmds()</code> <code>DISPLAY SMDS</code> smds <code>displaySmdsconn()</code> <code>DISPLAY SMDSCONN</code> smdsconn <code>displayStgclass()</code> <code>DISPLAY STGCLASS</code> stgclass <code>displaySub()</code> <code>DISPLAY SUB</code> sub <code>displaySvstatus()</code> <code>DISPLAY SVSTATUS</code> svstatus <code>displayTcluster()</code> <code>DISPLAY TCLUSTER</code> tcluster <code>displayThread()</code> <code>DISPLAY THREAD</code> thread <code>displayTopic()</code> <code>DISPLAY TOPIC</code> topic <code>displayTpstatus()</code> <code>DISPLAY TPSTATUS</code> tpstatus <code>displayTrace()</code> <code>DISPLAY TRACE</code> trace <code>displayUsage()</code> <code>DISPLAY USAGE</code> usage"},{"location":"api/commands/#define-methods","title":"DEFINE methods","text":"Method MQSC command Qualifier mapping <code>defineAuthinfo()</code> <code>DEFINE AUTHINFO</code> authinfo <code>defineBuffpool()</code> <code>DEFINE BUFFPOOL</code> buffpool <code>defineCfstruct()</code> <code>DEFINE CFSTRUCT</code> cfstruct <code>defineChannel()</code> <code>DEFINE CHANNEL</code> channel <code>defineComminfo()</code> <code>DEFINE COMMINFO</code> comminfo <code>defineListener()</code> <code>DEFINE LISTENER</code> listener <code>defineLog()</code> <code>DEFINE LOG</code> log <code>defineMaxsmsgs()</code> <code>DEFINE MAXSMSGS</code> maxsmsgs <code>defineNamelist()</code> <code>DEFINE NAMELIST</code> namelist <code>defineProcess()</code> <code>DEFINE PROCESS</code> process <code>definePsid()</code> <code>DEFINE PSID</code> psid <code>defineQalias()</code> <code>DEFINE QALIAS</code> queue <code>defineQlocal()</code> <code>DEFINE QLOCAL</code> queue <code>defineQmodel()</code> <code>DEFINE QMODEL</code> queue <code>defineQremote()</code> <code>DEFINE QREMOTE</code> queue <code>defineService()</code> <code>DEFINE SERVICE</code> service <code>defineStgclass()</code> <code>DEFINE STGCLASS</code> stgclass <code>defineSub()</code> <code>DEFINE SUB</code> sub <code>defineTopic()</code> <code>DEFINE TOPIC</code> topic"},{"location":"api/commands/#delete-methods","title":"DELETE methods","text":"Method MQSC command Qualifier mapping <code>deleteAuthinfo()</code> <code>DELETE AUTHINFO</code> authinfo <code>deleteAuthrec()</code> <code>DELETE AUTHREC</code> authrec <code>deleteBuffpool()</code> <code>DELETE BUFFPOOL</code> buffpool <code>deleteCfstruct()</code> <code>DELETE CFSTRUCT</code> cfstruct <code>deleteChannel()</code> <code>DELETE CHANNEL</code> channel <code>deleteComminfo()</code> <code>DELETE COMMINFO</code> comminfo <code>deleteListener()</code> <code>DELETE LISTENER</code> listener <code>deleteNamelist()</code> <code>DELETE NAMELIST</code> namelist <code>deletePolicy()</code> <code>DELETE POLICY</code> policy <code>deleteProcess()</code> <code>DELETE PROCESS</code> process <code>deletePsid()</code> <code>DELETE PSID</code> psid <code>deleteQueue()</code> <code>DELETE QUEUE</code> queue <code>deleteService()</code> <code>DELETE SERVICE</code> service <code>deleteStgclass()</code> <code>DELETE STGCLASS</code> stgclass <code>deleteSub()</code> <code>DELETE SUB</code> sub <code>deleteTopic()</code> <code>DELETE TOPIC</code> topic"},{"location":"api/commands/#alter-methods","title":"ALTER methods","text":"Method MQSC command Qualifier mapping <code>alterAuthinfo()</code> <code>ALTER AUTHINFO</code> authinfo <code>alterBuffpool()</code> <code>ALTER BUFFPOOL</code> buffpool <code>alterCfstruct()</code> <code>ALTER CFSTRUCT</code> cfstruct <code>alterChannel()</code> <code>ALTER CHANNEL</code> channel <code>alterComminfo()</code> <code>ALTER COMMINFO</code> comminfo <code>alterListener()</code> <code>ALTER LISTENER</code> listener <code>alterNamelist()</code> <code>ALTER NAMELIST</code> namelist <code>alterProcess()</code> <code>ALTER PROCESS</code> process <code>alterPsid()</code> <code>ALTER PSID</code> psid <code>alterQmgr()</code> <code>ALTER QMGR</code> qmgr <code>alterSecurity()</code> <code>ALTER SECURITY</code> security <code>alterService()</code> <code>ALTER SERVICE</code> service <code>alterSmds()</code> <code>ALTER SMDS</code> smds <code>alterStgclass()</code> <code>ALTER STGCLASS</code> stgclass <code>alterSub()</code> <code>ALTER SUB</code> sub <code>alterTopic()</code> <code>ALTER TOPIC</code> topic <code>alterTrace()</code> <code>ALTER TRACE</code> trace"},{"location":"api/commands/#set-methods","title":"SET methods","text":"Method MQSC command Qualifier mapping <code>setArchive()</code> <code>SET ARCHIVE</code> archive <code>setAuthrec()</code> <code>SET AUTHREC</code> authrec <code>setChlauth()</code> <code>SET CHLAUTH</code> chlauth <code>setLog()</code> <code>SET LOG</code> log <code>setPolicy()</code> <code>SET POLICY</code> policy"},{"location":"api/commands/#start-methods","title":"START methods","text":"Method MQSC command Qualifier mapping <code>startChannel()</code> <code>START CHANNEL</code> channel <code>startChinit()</code> <code>START CHINIT</code> chinit <code>startCmdserv()</code> <code>START CMDSERV</code> cmdserv <code>startListener()</code> <code>START LISTENER</code> listener <code>startQmgr()</code> <code>START QMGR</code> qmgr <code>startService()</code> <code>START SERVICE</code> service <code>startSmdsconn()</code> <code>START SMDSCONN</code> smdsconn <code>startTrace()</code> <code>START TRACE</code> trace"},{"location":"api/commands/#stop-methods","title":"STOP methods","text":"Method MQSC command Qualifier mapping <code>stopChannel()</code> <code>STOP CHANNEL</code> channel <code>stopChinit()</code> <code>STOP CHINIT</code> chinit <code>stopCmdserv()</code> <code>STOP CMDSERV</code> cmdserv <code>stopConn()</code> <code>STOP CONN</code> conn <code>stopListener()</code> <code>STOP LISTENER</code> listener <code>stopQmgr()</code> <code>STOP QMGR</code> qmgr <code>stopService()</code> <code>STOP SERVICE</code> service <code>stopSmdsconn()</code> <code>STOP SMDSCONN</code> smdsconn <code>stopTrace()</code> <code>STOP TRACE</code> trace"},{"location":"api/commands/#other-methods","title":"Other methods","text":"Method MQSC command Qualifier mapping <code>archiveLog()</code> <code>ARCHIVE LOG</code> log <code>backupCfstruct()</code> <code>BACKUP CFSTRUCT</code> cfstruct <code>clearQlocal()</code> <code>CLEAR QLOCAL</code> queue <code>clearTopicstr()</code> <code>CLEAR TOPICSTR</code> topicstr <code>moveQlocal()</code> <code>MOVE QLOCAL</code> queue <code>pingChannel()</code> <code>PING CHANNEL</code> channel <code>pingQmgr()</code> <code>PING QMGR</code> qmgr <code>purgeChannel()</code> <code>PURGE CHANNEL</code> channel <code>recoverBsds()</code> <code>RECOVER BSDS</code> bsds <code>recoverCfstruct()</code> <code>RECOVER CFSTRUCT</code> cfstruct <code>refreshCluster()</code> <code>REFRESH CLUSTER</code> cluster <code>refreshQmgr()</code> <code>REFRESH QMGR</code> qmgr <code>refreshSecurity()</code> <code>REFRESH SECURITY</code> security <code>resetCfstruct()</code> <code>RESET CFSTRUCT</code> cfstruct <code>resetChannel()</code> <code>RESET CHANNEL</code> channel <code>resetCluster()</code> <code>RESET CLUSTER</code> cluster <code>resetQmgr()</code> <code>RESET QMGR</code> qmgr <code>resetQstats()</code> <code>RESET QSTATS</code> queue <code>resetSmds()</code> <code>RESET SMDS</code> smds <code>resetTpipe()</code> <code>RESET TPIPE</code> tpipe <code>resolveChannel()</code> <code>RESOLVE CHANNEL</code> channel <code>resolveIndoubt()</code> <code>RESOLVE INDOUBT</code> indoubt <code>resumeQmgr()</code> <code>RESUME QMGR</code> qmgr <code>rverifySecurity()</code> <code>RVERIFY SECURITY</code> security <code>suspendQmgr()</code> <code>SUSPEND QMGR</code> qmgr <p>Note</p> <p>The full list of command methods is generated from the mapping data. See the Qualifier Mapping Reference for per-qualifier details including attribute names and value mappings for each object type.</p>"},{"location":"api/ensure/","title":"Ensure","text":""},{"location":"api/ensure/#overview","title":"Overview","text":"<p>The ensure package provides the return types for the 16 idempotent ensure methods on <code>MqRestSession</code>. These methods implement a declarative upsert pattern: DEFINE if the object does not exist, ALTER only attributes that differ, or no-op if the object already matches the desired state.</p>"},{"location":"api/ensure/#ensureaction","title":"EnsureAction","text":"<p>An enum indicating the action taken by an ensure method:</p> <pre><code>public enum EnsureAction {\n    CREATED,    // Object did not exist; DEFINE was issued\n    UPDATED,    // Object existed but attributes differed; ALTER was issued\n    UNCHANGED   // Object already matched the desired state\n}\n</code></pre>"},{"location":"api/ensure/#ensureresult","title":"EnsureResult","text":"<p>A record containing the action taken and the list of attribute names that triggered the change (if any):</p> <pre><code>public record EnsureResult(\n    EnsureAction action,\n    List&lt;String&gt; changed    // attribute names that differed (empty for CREATED/UNCHANGED)\n) {}\n</code></pre> Method Return type Description <code>action()</code> <code>EnsureAction</code> What happened: <code>CREATED</code>, <code>UPDATED</code>, or <code>UNCHANGED</code> <code>changed()</code> <code>List&lt;String&gt;</code> Attribute names that triggered an ALTER (in the caller's namespace)"},{"location":"api/ensure/#usage","title":"Usage","text":"<pre><code>EnsureResult result = session.ensureQlocal(\"MY.QUEUE\",\n    Map.of(\"max_queue_depth\", 50000, \"description\", \"App queue\"));\n\nswitch (result.action()) {\n    case CREATED   -&gt; System.out.println(\"Queue created\");\n    case UPDATED   -&gt; System.out.println(\"Changed: \" + result.changed());\n    case UNCHANGED -&gt; System.out.println(\"Already correct\");\n}\n</code></pre> <p>See Ensure Methods for the full conceptual overview, comparison logic, and the complete list of available ensure methods.</p>"},{"location":"api/exceptions/","title":"Exceptions","text":""},{"location":"api/exceptions/#hierarchy","title":"Hierarchy","text":"<p>All exceptions are unchecked (extend <code>RuntimeException</code>) and sealed:</p> <pre><code>MqRestException (sealed, extends RuntimeException)\n\u251c\u2500\u2500 MqRestTransportException   \u2014 Network/connection failures\n\u251c\u2500\u2500 MqRestResponseException    \u2014 Malformed JSON, unexpected structure\n\u251c\u2500\u2500 MqRestAuthException        \u2014 Authentication/authorization failures\n\u251c\u2500\u2500 MqRestCommandException     \u2014 MQSC command returned error codes\n\u2514\u2500\u2500 MqRestTimeoutException     \u2014 Polling timeout exceeded\n\nMappingException               \u2014 Attribute mapping failures (separate hierarchy)\n</code></pre> <p>Because the hierarchy is sealed, a <code>catch (MqRestException e)</code> block catches all library exceptions, and you can use pattern matching or <code>instanceof</code> to handle specific subtypes.</p>"},{"location":"api/exceptions/#mqrestexception","title":"MqRestException","text":"<p>The base exception class. All library exceptions extend this sealed class. It carries the standard <code>message</code> and optional <code>cause</code> from <code>RuntimeException</code>.</p>"},{"location":"api/exceptions/#mqresttransportexception","title":"MqRestTransportException","text":"<p>Thrown when the HTTP request fails at the network level \u2014 connection refused, DNS resolution failure, TLS handshake error, etc.</p> Method Return type Description <code>getUrl()</code> <code>String</code> The URL that was being accessed <pre><code>try {\n    session.displayQueue(\"MY.QUEUE\");\n} catch (MqRestTransportException e) {\n    System.err.println(\"Cannot reach: \" + e.getUrl());\n    System.err.println(\"Cause: \" + e.getCause().getMessage());\n}\n</code></pre>"},{"location":"api/exceptions/#mqrestresponseexception","title":"MqRestResponseException","text":"<p>Thrown when the HTTP request succeeds but the response cannot be parsed \u2014 invalid JSON, missing expected fields, unexpected response structure.</p> Method Return type Description <code>getResponseText()</code> <code>String</code> Raw response body (may be <code>null</code>)"},{"location":"api/exceptions/#mqrestauthexception","title":"MqRestAuthException","text":"<p>Thrown when authentication or authorization fails \u2014 invalid credentials, expired tokens, insufficient permissions (HTTP 401/403).</p> Method Return type Description <code>getUrl()</code> <code>String</code> The URL that was being accessed <code>getStatusCode()</code> <code>Integer</code> HTTP status code (may be <code>null</code>) <pre><code>try {\n    session.displayQmgr();\n} catch (MqRestAuthException e) {\n    System.err.println(\"Auth failed: HTTP \" + e.getStatusCode());\n}\n</code></pre>"},{"location":"api/exceptions/#mqrestcommandexception","title":"MqRestCommandException","text":"<p>Thrown when the MQSC command returns a non-zero completion or reason code. This is the most commonly caught exception \u2014 it indicates the command was delivered to MQ but the queue manager rejected it.</p> Method Return type Description <code>getPayload()</code> <code>Map&lt;String, Object&gt;</code> Full response payload (unmodifiable) <code>getStatusCode()</code> <code>Integer</code> HTTP status code (may be <code>null</code>) <pre><code>try {\n    session.defineQlocal(\"MY.QUEUE\", Map.of());\n} catch (MqRestCommandException e) {\n    System.err.println(e.getMessage());\n    System.err.println(\"HTTP status: \" + e.getStatusCode());\n    System.err.println(\"Response: \" + e.getPayload());\n}\n</code></pre> <p>Note</p> <p>For DISPLAY commands with no matches, MQ returns reason code 2085 (MQRC_UNKNOWN_OBJECT_NAME). The library treats this as an empty list rather than throwing an exception.</p>"},{"location":"api/exceptions/#mqresttimeoutexception","title":"MqRestTimeoutException","text":"<p>Thrown when a polling operation exceeds the configured timeout duration.</p> Method Return type Description <code>getName()</code> <code>String</code> Resource name being polled <code>getOperation()</code> <code>String</code> Operation being performed <code>getElapsed()</code> <code>double</code> Elapsed time in seconds"},{"location":"api/exceptions/#mappingexception","title":"MappingException","text":"<p><code>io.github.wphillipmoore.mq.rest.admin.mapping.MappingException</code></p> <p>Separate from the <code>MqRestException</code> hierarchy. Thrown by the mapping layer when strict-mode attribute translation fails. Contains the list of <code>MappingIssue</code> instances that caused the failure.</p> <p>See Mapping for details.</p>"},{"location":"api/exceptions/#catching-exceptions","title":"Catching exceptions","text":"<p>Catch the base class for broad error handling, or specific subtypes for targeted recovery:</p> <pre><code>try {\n    session.defineQlocal(\"MY.QUEUE\", Map.of(\"max_queue_depth\", 50000));\n} catch (MqRestCommandException e) {\n    // MQSC command failed \u2014 check reason code in payload\n    System.err.println(\"Command failed: \" + e.getMessage());\n} catch (MqRestAuthException e) {\n    // Credentials rejected\n    System.err.println(\"Not authorized: \" + e.getStatusCode());\n} catch (MqRestTransportException e) {\n    // Network error\n    System.err.println(\"Connection failed to \" + e.getUrl());\n} catch (MqRestException e) {\n    // Catch-all for any other library exception\n    System.err.println(\"Unexpected error: \" + e.getMessage());\n}\n</code></pre>"},{"location":"api/mapping/","title":"Mapping","text":""},{"location":"api/mapping/#overview","title":"Overview","text":"<p>The mapping package provides bidirectional attribute translation between developer-friendly <code>snake_case</code> names and native MQSC parameter names. The mapper is created internally by <code>MqRestSession</code> from <code>MappingData</code> and is not typically used directly.</p> <p>See Mapping Pipeline for a conceptual overview of how mapping works.</p>"},{"location":"api/mapping/#attributemapper","title":"AttributeMapper","text":"<p>The core mapping engine. Translates attribute names and values between the developer-friendly namespace and the MQSC namespace. The mapper performs three types of translation in each direction:</p> <ul> <li>Key mapping: Attribute name translation (e.g. <code>current_queue_depth</code> \u2194   <code>CURDEPTH</code>)</li> <li>Value mapping: Enumerated value translation (e.g. <code>\"yes\"</code> \u2194 <code>\"YES\"</code>,   <code>\"server_connection\"</code> \u2194 <code>\"SVRCONN\"</code>)</li> <li>Key-value mapping: Combined name+value translation for cases where both   key and value change together (e.g. <code>channel_type=\"server_connection\"</code> \u2192   <code>CHLTYPE(\"SVRCONN\")</code>)</li> </ul> <p>The mapper is qualifier-aware: it selects the correct mapping tables based on the MQSC command's qualifier (e.g. <code>queue</code>, <code>channel</code>, <code>qmgr</code>).</p>"},{"location":"api/mapping/#mappingdata","title":"MappingData","text":"<p>Holds the complete mapping tables loaded from the JSON resource file at:</p> <pre><code>src/main/resources/io/github/wphillipmoore/mq/rest/admin/mapping/mapping-data.json\n</code></pre> <p>The data is organized by qualifier (e.g. <code>queue</code>, <code>channel</code>, <code>qmgr</code>) with separate maps for request and response directions. Each qualifier contains:</p> <ul> <li><code>request_key_map</code> \u2014 developer-friendly \u2192 MQSC key mapping for requests</li> <li><code>request_value_map</code> \u2014 value translations for request attributes</li> <li><code>request_key_value_map</code> \u2014 combined key+value translations for requests</li> <li><code>response_key_map</code> \u2014 MQSC \u2192 developer-friendly key mapping for responses</li> <li><code>response_value_map</code> \u2014 value translations for response attributes</li> </ul> <p>The mapping data was originally bootstrapped from IBM MQ 9.4 documentation and covers all standard MQSC attributes across 42 qualifiers.</p>"},{"location":"api/mapping/#mappingoverridemode","title":"MappingOverrideMode","text":"<p>Controls how custom overrides are merged with built-in mapping data:</p> <pre><code>public enum MappingOverrideMode {\n    MERGE,    // default \u2014 overlay at key level, preserve unmentioned entries\n    REPLACE   // completely replace the specified sub-map\n}\n</code></pre> <ul> <li>MERGE (default): Override entries are merged at the key level within each   sub-map. Existing entries not mentioned in the override are preserved. This is   the common case for changing a few attribute names without losing the rest.</li> <li>REPLACE: The override completely replaces the specified sub-map. Use when   you need full control over a qualifier's mapping.</li> </ul>"},{"location":"api/mapping/#mappingissue","title":"MappingIssue","text":"<p>Tracks mapping problems encountered during translation:</p> <ul> <li>Unknown attribute names (not found in key map)</li> <li>Unknown attribute values (not found in value map)</li> <li>Ambiguous mappings</li> </ul> <p>In strict mode, any <code>MappingIssue</code> causes a <code>MappingException</code>. In lenient mode, issues are collected but the unmapped values pass through unchanged.</p>"},{"location":"api/mapping/#mappingexception","title":"MappingException","text":"<p><code>io.github.wphillipmoore.mq.rest.admin.mapping.MappingException</code></p> <p>Thrown when attribute mapping fails in strict mode. Separate from the <code>MqRestException</code> hierarchy (it does not extend <code>MqRestException</code>). Contains the list of <code>MappingIssue</code> instances that caused the failure.</p> <pre><code>try {\n    session.displayQueue(\"MY.QUEUE\",\n        Map.of(\"response_parameters\", List.of(\"invalid_attribute_name\")));\n} catch (MappingException e) {\n    // e.getMessage() describes the unmappable attributes\n}\n</code></pre>"},{"location":"api/session/","title":"MqRestSession","text":""},{"location":"api/session/#overview","title":"Overview","text":"<p>The main entry point for interacting with an IBM MQ queue manager's administrative REST API. A session encapsulates connection details, authentication, attribute mapping configuration, and diagnostic state. It provides ~144 command methods covering all MQSC verbs and qualifiers, plus 16 idempotent ensure methods for declarative object management.</p> <p>Unlike the Python implementation which decomposes functionality across mixins, the Java session is a single class with all methods directly available.</p>"},{"location":"api/session/#creating-a-session","title":"Creating a session","text":"<p>Use the builder pattern:</p> <pre><code>import io.github.wphillipmoore.mq.rest.admin.MqRestSession;\nimport io.github.wphillipmoore.mq.rest.admin.auth.LtpaAuth;\n\nvar session = MqRestSession.builder()\n    .host(\"localhost\")\n    .port(9443)\n    .queueManager(\"QM1\")\n    .credentials(new LtpaAuth(\"admin\", \"passw0rd\"))\n    .build();\n</code></pre> <p>The builder validates all required fields and constructs the base URL, transport, and mapping data at build time. Errors in configuration (e.g. invalid mapping overrides) are caught immediately.</p>"},{"location":"api/session/#builder-options","title":"Builder options","text":"Method Type Description <code>host(String)</code> Required Hostname or IP of the MQ REST API <code>port(int)</code> Required HTTPS port <code>queueManager(String)</code> Required Target queue manager name <code>credentials(Credentials)</code> Required Authentication credentials <code>gatewayQmgr(String)</code> Optional Gateway queue manager for remote routing <code>mapAttributes(boolean)</code> Optional Enable/disable attribute mapping (default: <code>true</code>) <code>mappingStrict(boolean)</code> Optional Strict or lenient mapping mode (default: <code>true</code>) <code>mappingOverrides(Map)</code> Optional Custom mapping overrides (sparse merge) <code>verifyTls(boolean)</code> Optional Verify server TLS certificates (default: <code>true</code>) <code>sslContext(SSLContext)</code> Optional Custom <code>SSLContext</code> for TLS/mTLS <code>timeout(Duration)</code> Optional Default request timeout <code>csrfToken(String)</code> Optional Custom CSRF token value <code>transport(MqRestTransport)</code> Optional Custom transport implementation"},{"location":"api/session/#minimal-example","title":"Minimal example","text":"<pre><code>var session = MqRestSession.builder()\n    .host(\"localhost\")\n    .port(9443)\n    .queueManager(\"QM1\")\n    .credentials(new LtpaAuth(\"admin\", \"passw0rd\"))\n    .build();\n</code></pre>"},{"location":"api/session/#full-example","title":"Full example","text":"<pre><code>var session = MqRestSession.builder()\n    .host(\"mq-server.example.com\")\n    .port(9443)\n    .queueManager(\"QM2\")\n    .credentials(new LtpaAuth(\"mqadmin\", \"mqadmin\"))\n    .gatewayQmgr(\"QM1\")\n    .mapAttributes(true)\n    .mappingStrict(false)\n    .mappingOverrides(overrides)\n    .verifyTls(true)\n    .sslContext(sslContext)\n    .timeout(Duration.ofSeconds(30))\n    .build();\n</code></pre>"},{"location":"api/session/#command-methods","title":"Command methods","text":"<p>The session provides ~144 command methods, one for each MQSC verb + qualifier combination. See Commands for the full list.</p> <pre><code>// DISPLAY commands return a list of maps\nList&lt;Map&lt;String, Object&gt;&gt; queues = session.displayQueue(\"APP.*\");\n\n// Queue manager singletons return a single map or null\nMap&lt;String, Object&gt; qmgr = session.displayQmgr();\n\n// Non-DISPLAY commands return void (throw on error)\nsession.defineQlocal(\"MY.QUEUE\", Map.of(\"max_queue_depth\", 50000));\nsession.deleteQlocal(\"MY.QUEUE\");\n</code></pre>"},{"location":"api/session/#ensure-methods","title":"Ensure methods","text":"<p>The session provides 16 ensure methods for declarative object management. Each method implements an idempotent upsert: DEFINE if the object does not exist, ALTER only the attributes that differ, or no-op if already correct.</p> <pre><code>EnsureResult result = session.ensureQlocal(\"MY.QUEUE\",\n    Map.of(\"max_queue_depth\", 50000));\n// result.action() is CREATED, UPDATED, or UNCHANGED\n</code></pre> <p>See Ensure Methods for detailed usage and the full list of available ensure methods.</p>"},{"location":"api/session/#diagnostic-state","title":"Diagnostic state","text":"<p>The session retains the most recent request and response for inspection. This is useful for debugging command failures or understanding what the library sent to the MQ REST API:</p> <pre><code>session.displayQueue(\"MY.QUEUE\");\n\nsession.getLastCommandPayload();    // the JSON sent to MQ (unmodifiable Map)\nsession.getLastResponsePayload();   // the parsed JSON response (unmodifiable Map)\nsession.getLastHttpStatus();        // HTTP status code (int)\nsession.getLastResponseText();      // raw response body (String)\n</code></pre>"},{"location":"api/session/#accessor-methods","title":"Accessor methods","text":"Method Return type Description <code>getQmgrName()</code> <code>String</code> Queue manager name <code>getGatewayQmgr()</code> <code>String</code> Gateway queue manager (or <code>null</code>) <code>getLastHttpStatus()</code> <code>int</code> HTTP status code from last command <code>getLastResponseText()</code> <code>String</code> Raw response body from last command <code>getLastResponsePayload()</code> <code>Map&lt;String, Object&gt;</code> Parsed response (unmodifiable) <code>getLastCommandPayload()</code> <code>Map&lt;String, Object&gt;</code> Command sent (unmodifiable)"},{"location":"api/session/#sync","title":"Sync","text":"<p>The session provides bulk sync operations. See Sync for details.</p>"},{"location":"api/sync/","title":"Sync","text":""},{"location":"api/sync/#overview","title":"Overview","text":"<p>The sync package provides the types for the 9 synchronous start/stop/restart methods on <code>MqRestSession</code>. These methods wrap fire-and-forget <code>START</code> and <code>STOP</code> commands with a polling loop that waits until the object reaches its target state or the timeout expires.</p>"},{"location":"api/sync/#syncoperation","title":"SyncOperation","text":"<p>An enum indicating the operation that was performed:</p> <pre><code>public enum SyncOperation {\n    STARTED,    // Object confirmed running\n    STOPPED,    // Object confirmed stopped\n    RESTARTED   // Stop-then-start completed\n}\n</code></pre>"},{"location":"api/sync/#syncconfig","title":"SyncConfig","text":"<p>A record controlling the polling behaviour:</p> <pre><code>public record SyncConfig(\n    double timeoutSeconds,       // Max wait before raising (default 30)\n    double pollIntervalSeconds   // Seconds between polls (default 1)\n) {}\n</code></pre> Method Return type Description <code>timeoutSeconds()</code> <code>double</code> Maximum seconds to wait before raising <code>MqRestTimeoutException</code> <code>pollIntervalSeconds()</code> <code>double</code> Seconds between <code>DISPLAY *STATUS</code> polls"},{"location":"api/sync/#syncresult","title":"SyncResult","text":"<p>A record containing the outcome of a sync operation:</p> <pre><code>public record SyncResult(\n    SyncOperation operation,   // What happened: STARTED, STOPPED, or RESTARTED\n    int polls,                 // Number of status polls issued\n    double elapsedSeconds      // Wall-clock time from command to confirmation\n) {}\n</code></pre> Method Return type Description <code>operation()</code> <code>SyncOperation</code> What happened: <code>STARTED</code>, <code>STOPPED</code>, or <code>RESTARTED</code> <code>polls()</code> <code>int</code> Number of status polls issued <code>elapsedSeconds()</code> <code>double</code> Wall-clock seconds from command to confirmation"},{"location":"api/sync/#method-signature-pattern","title":"Method signature pattern","text":"<p>All 9 sync methods follow the same signature pattern:</p> <pre><code>SyncResult startChannelSync(String name);\nSyncResult startChannelSync(String name, SyncConfig config);\n</code></pre>"},{"location":"api/sync/#usage","title":"Usage","text":"<pre><code>SyncResult result = session.startChannelSync(\"TO.PARTNER\");\n\nswitch (result.operation()) {\n    case STARTED   -&gt; System.out.println(\"Running after \" + result.polls() + \" polls\");\n    case STOPPED   -&gt; System.out.println(\"Stopped\");\n    case RESTARTED -&gt; System.out.println(\"Restarted in \" + result.elapsedSeconds() + \"s\");\n}\n</code></pre> <p>See Sync Methods for the full conceptual overview, polling behaviour, and the complete list of available methods.</p>"},{"location":"api/transport/","title":"Transport","text":""},{"location":"api/transport/#overview","title":"Overview","text":"<p>The transport layer abstracts HTTP communication from the session logic. The session builds <code>runCommandJSON</code> payloads and delegates HTTP delivery to a transport implementation. This separation enables testing the entire command pipeline without an MQ server by injecting a mock transport.</p>"},{"location":"api/transport/#mqresttransport","title":"MqRestTransport","text":"<p>The transport interface defines a single method for posting JSON payloads:</p> <pre><code>public interface MqRestTransport {\n    TransportResponse postJson(\n        String url,\n        Map&lt;String, Object&gt; payload,\n        Map&lt;String, String&gt; headers,\n        Duration timeout,\n        boolean verifyTls\n    );\n}\n</code></pre> Parameter Description <code>url</code> Fully-qualified endpoint URL <code>payload</code> The <code>runCommandJSON</code> request body <code>headers</code> Authentication, CSRF token, and optional gateway headers <code>timeout</code> Per-request timeout duration <code>verifyTls</code> Whether to verify server certificates <p>Throws <code>MqRestTransportException</code> on network failures.</p>"},{"location":"api/transport/#httpclienttransport","title":"HttpClientTransport","text":"<p>The default transport implementation using <code>java.net.http.HttpClient</code> (JDK built-in, zero additional dependencies beyond Gson for JSON serialization):</p> <pre><code>// Default \u2014 verifies TLS certificates\nvar transport = new HttpClientTransport();\n\n// Custom SSLContext for mTLS client certificate authentication\nvar transport = new HttpClientTransport(sslContext);\n</code></pre> <p><code>HttpClientTransport</code> handles:</p> <ul> <li>HTTPS connections with configurable <code>SSLContext</code></li> <li>Automatic TLS certificate verification (or disabled via <code>verifyTls=false</code>)</li> <li>Request timeouts via <code>Duration</code></li> <li>JSON serialization/deserialization with Gson</li> <li>Custom HTTP headers</li> <li>Defensive header flattening per RFC 9110</li> </ul>"},{"location":"api/transport/#transportresponse","title":"TransportResponse","text":"<p>An immutable record containing the HTTP response data:</p> <pre><code>public record TransportResponse(\n    int statusCode,\n    String body,                   // never null (empty string if no body)\n    Map&lt;String, String&gt; headers    // never null, unmodifiable\n) {}\n</code></pre>"},{"location":"api/transport/#custom-transport","title":"Custom transport","text":"<p>Implement <code>MqRestTransport</code> to provide custom HTTP behavior or for testing. Because the interface has a single method, a lambda works naturally:</p> <pre><code>// Mock transport for unit tests\nMqRestTransport mockTransport = (url, payload, headers, timeout, verify) -&gt;\n    new TransportResponse(200, responseJson, Map.of());\n\nvar session = MqRestSession.builder()\n    .host(\"localhost\")\n    .port(9443)\n    .queueManager(\"QM1\")\n    .credentials(new LtpaAuth(\"admin\", \"passw0rd\"))\n    .transport(mockTransport)\n    .build();\n</code></pre> <p>This pattern is used extensively in the library's own test suite to verify command payload construction, response parsing, and error handling without network access.</p>"},{"location":"design/","title":"Design","text":"<p>These pages document design decisions and the MQ REST API protocol details that inform the library's architecture.</p> <ul> <li>Rationale \u2014 Why this library exists and key design choices</li> <li>runCommandJSON Endpoint \u2014 The MQ REST API endpoint</li> <li>Nested Object Flattening \u2014 Handling nested responses</li> </ul>"},{"location":"design/nested-object-flattening/","title":"Nested Object Flattening","text":""},{"location":"design/rationale/","title":"Design Rationale","text":"<p>In the Java implementation, method names use <code>camelCase</code> (e.g. <code>displayQueue()</code>, <code>defineQlocal()</code>) rather than <code>snake_case</code>, following Java conventions. The underlying design rationale is identical.</p>"},{"location":"design/runcommand-endpoint/","title":"The runCommandJSON Endpoint","text":""},{"location":"development/","title":"Development","text":"<p>Guides for contributors and developers working on mq-rest-admin.</p> <ul> <li>Developer Setup \u2014 Build environment and tools</li> <li>Contributing \u2014 How to contribute</li> <li>Local MQ Container \u2014 Running MQ locally for testing</li> </ul>"},{"location":"development/contributing/","title":"Contributing","text":"<p>This project welcomes contributions from humans working with or without AI assistance. AI tooling is available but not required.</p>"},{"location":"development/contributing/#branch-workflow","title":"Branch workflow","text":"<p>This project follows a library-release branching model:</p> <ul> <li><code>main</code>: Release branch \u2014 tagged releases only</li> <li><code>develop</code>: Integration branch \u2014 PRs merge here</li> <li><code>feature/*</code>: Feature branches \u2014 created from <code>develop</code></li> <li><code>release/*</code>: Release preparation branches</li> </ul> <p>Branch from <code>develop</code> using <code>feature/*</code>, <code>bugfix/*</code>, <code>hotfix/*</code>, or <code>chore/*</code> prefixes.</p>"},{"location":"development/contributing/#commit-conventions","title":"Commit conventions","text":"<p>Commits must follow the Conventional Commits format:</p> <pre><code>&lt;type&gt;: &lt;description&gt;\n\n[optional body]\n\n[optional footer(s)]\n</code></pre> <p>Types: <code>feat</code>, <code>fix</code>, <code>docs</code>, <code>style</code>, <code>refactor</code>, <code>test</code>, <code>chore</code></p>"},{"location":"development/contributing/#code-quality-requirements","title":"Code quality requirements","text":"<p>All code must pass the full validation pipeline before merging:</p> Gate Tool Formatting Spotless with google-java-format (2-space indent) Style Checkstyle with <code>google_checks.xml</code> Coverage JaCoCo \u2014 100% line and branch coverage Bug analysis SpotBugs (Max effort, Low threshold) Code smells PMD Markdown lint markdownlint Commit messages Conventional commit validation <p>Run the full suite locally before pushing:</p> <pre><code>./mvnw verify\n</code></pre> <p>Run <code>./mvnw spotless:apply</code> to auto-format before committing.</p>"},{"location":"development/contributing/#pull-request-process","title":"Pull request process","text":"<ol> <li>Create a <code>feature/*</code> branch from <code>develop</code></li> <li>Make changes and ensure <code>./mvnw verify</code> passes</li> <li>Open a PR targeting <code>develop</code></li> <li>PR body must include <code>Fixes #N</code> or <code>Ref #N</code> (validated by CI)</li> <li>CI runs the full validation pipeline</li> <li>After review and approval, squash-merge into <code>develop</code></li> </ol>"},{"location":"development/contributing/#for-human-contributors","title":"For human contributors","text":"<ul> <li>Run <code>./mvnw verify</code> before pushing to catch issues early.</li> <li>Reference <code>docs/repository-standards.md</code> for the full standards   specification.</li> <li>The <code>CLAUDE.md</code> and <code>AGENTS.md</code> files document architecture,   patterns, and key design decisions. They are useful as reference   material even when not using an AI agent.</li> </ul>"},{"location":"development/contributing/#for-ai-agent-contributors","title":"For AI agent contributors","text":""},{"location":"development/contributing/#agent-entry-points","title":"Agent entry points","text":"<ul> <li>Claude Code: reads <code>CLAUDE.md</code>, which loads repository standards   via include directives.</li> <li>Codex and other agents: reads <code>AGENTS.md</code>, which loads the same   standards plus shared skills from the <code>standards-and-conventions</code>   repository.</li> </ul>"},{"location":"development/contributing/#quality-expectations","title":"Quality expectations","text":"<p>AI-generated code must pass all the same validation gates listed above. There are no exceptions.</p>"},{"location":"development/contributing/#what-ai-agents-handle-well","title":"What AI agents handle well","text":"<ul> <li>Code generation from mapping data</li> <li>Test writing and coverage gap filling</li> <li>Linting and formatting fixes</li> <li>Refactoring with consistent patterns</li> <li>PR creation and submission</li> </ul>"},{"location":"development/contributing/#what-requires-human-judgment","title":"What requires human judgment","text":"<ul> <li>Architectural decisions and API design</li> <li>MQ domain knowledge and MQSC semantics</li> <li>Release decisions and version management</li> <li>Mapping data curation (attribute names, value translations)</li> </ul>"},{"location":"development/contributing/#co-author-trailers","title":"Co-author trailers","text":"<p>AI agents add co-author trailers to commits automatically when following the repository standards.</p>"},{"location":"development/developer-setup/","title":"Developer Setup","text":"<p>This guide covers everything needed to develop and test mq-rest-admin locally.</p>"},{"location":"development/developer-setup/#prerequisites","title":"Prerequisites","text":"Tool Version Purpose Java 17+ Runtime (install via SDKMAN or <code>brew install openjdk@17</code>) Maven 3.9+ Provided by Maven Wrapper (<code>./mvnw</code>) Python 3.12+ MkDocs documentation builds and mapping doc generation Docker Latest Local MQ containers (integration tests) <code>markdownlint</code> Latest Docs validation"},{"location":"development/developer-setup/#required-repositories","title":"Required repositories","text":"<p>mq-rest-admin depends on two sibling repositories:</p> Repository Purpose mq-rest-admin-java This project standards-and-conventions Canonical project standards (referenced by <code>AGENTS.md</code> and git hooks) mq-dev-environment Dockerized MQ test infrastructure (local and CI) mq-rest-admin-common Shared documentation fragments"},{"location":"development/developer-setup/#recommended-directory-layout","title":"Recommended directory layout","text":"<p>Clone all repositories as siblings:</p> <pre><code>~/dev/github/\n\u251c\u2500\u2500 mq-rest-admin-java/\n\u251c\u2500\u2500 mq-rest-admin-common/\n\u251c\u2500\u2500 standards-and-conventions/\n\u2514\u2500\u2500 mq-dev-environment/\n</code></pre> <pre><code>cd ~/dev/github\ngit clone https://github.com/wphillipmoore/mq-rest-admin-java.git\ngit clone https://github.com/wphillipmoore/mq-rest-admin-common.git\ngit clone https://github.com/wphillipmoore/standards-and-conventions.git\ngit clone https://github.com/wphillipmoore/mq-dev-environment.git\n</code></pre>"},{"location":"development/developer-setup/#initial-setup","title":"Initial setup","text":"<pre><code>cd mq-rest-admin-java\n\n# Compile and run all quality checks\n./mvnw verify\n\n# Enable repository git hooks\ngit config core.hooksPath scripts/git-hooks\n</code></pre>"},{"location":"development/developer-setup/#building","title":"Building","text":"<pre><code>./mvnw compile          # Compile sources\n./mvnw clean            # Remove target/\n./mvnw clean compile    # Clean rebuild\n./mvnw package          # Compile and package JAR\n</code></pre>"},{"location":"development/developer-setup/#validation-pipeline","title":"Validation pipeline","text":"<p>The full validation pipeline runs all quality checks in sequence:</p> <pre><code>./mvnw verify\n</code></pre> <p>This runs: formatting check (Spotless) \u2192 style check (Checkstyle) \u2192 compile \u2192 unit tests (Surefire) \u2192 integration tests (Failsafe) \u2192 coverage enforcement (JaCoCo 100% line + branch) \u2192 bug analysis (SpotBugs) \u2192 code smell detection (PMD).</p> <p>Individual tools can be run standalone:</p> <pre><code>./mvnw spotless:check      # Check formatting\n./mvnw spotless:apply      # Auto-format code\n./mvnw checkstyle:check    # Check style rules\n./mvnw spotbugs:check      # Check for bug patterns\n./mvnw pmd:check           # Check for code smells\n</code></pre>"},{"location":"development/developer-setup/#testing","title":"Testing","text":"<pre><code>./mvnw test                # Unit tests only (*Test.java)\n./mvnw verify              # Unit + integration tests (*IT.java)\n</code></pre> <ul> <li>Framework: JUnit 5 (Jupiter)</li> <li>Mocking: Mockito 5 with <code>@ExtendWith(MockitoExtension.class)</code></li> <li>Assertions: AssertJ (<code>assertThat(x).isEqualTo(y)</code>)</li> <li>Coverage: JaCoCo \u2014 100% line and branch coverage enforced</li> </ul>"},{"location":"development/developer-setup/#running-integration-tests","title":"Running integration tests","text":"<p>Integration tests require running MQ containers. Start the containers, seed test objects, then run the tests:</p> <pre><code># Start both queue managers\nscripts/dev/mq_start.sh\n\n# Seed deterministic test objects\nscripts/dev/mq_seed.sh\n\n# Run integration tests\nMQ_REST_ADMIN_RUN_INTEGRATION=1 ./mvnw verify\n\n# Stop MQ when done\nscripts/dev/mq_stop.sh\n</code></pre> <p>See local MQ container for full container configuration, credentials, gateway routing, and troubleshooting.</p>"},{"location":"development/developer-setup/#git-hooks","title":"Git hooks","text":"<p>Enable repository git hooks before committing:</p> <pre><code>git config core.hooksPath scripts/git-hooks\n</code></pre> <p>The hooks enforce:</p> <ul> <li>pre-commit: Branch naming conventions and protected branch rules</li> <li>commit-msg: Conventional Commits format and co-author trailer validation</li> </ul>"},{"location":"development/developer-setup/#documentation","title":"Documentation","text":""},{"location":"development/developer-setup/#local-setup","title":"Local setup","text":"<pre><code># Set up shared fragments symlink\nscripts/dev/docs-setup.sh\n\n# Install MkDocs\npip install mkdocs-material\n\n# Generate mapping docs\npython scripts/dev/generate_mapping_docs.py\n\n# Build the documentation site\nmkdocs build -f docs/site/mkdocs.yml\n\n# Serve locally with live reload\nmkdocs serve -f docs/site/mkdocs.yml\n</code></pre>"},{"location":"development/developer-setup/#javadoc","title":"Javadoc","text":"<pre><code>./mvnw javadoc:javadoc\n</code></pre> <p>Output is generated to <code>docs/site/site/javadoc/</code>.</p>"},{"location":"development/developer-setup/#ci-pipeline-overview","title":"CI pipeline overview","text":"<p>CI runs on every pull request and enforces the same gates as local validation. The pipeline includes:</p> <ul> <li>Unit tests on Java 17, 21, and 25-ea</li> <li>Integration tests against real MQ queue managers via the shared   <code>wphillipmoore/mq-dev-environment/.github/actions/setup-mq</code> action</li> <li>Standards compliance (Spotless, Checkstyle, SpotBugs, PMD, markdown   lint, commit messages, repository profile)</li> <li>Dependency audit (<code>dependency-check</code>)</li> <li>Release gates (version checks, changelog validation) for PRs   targeting <code>main</code></li> </ul>"},{"location":"development/local-mq-container/","title":"Local MQ Container","text":""},{"location":"development/local-mq-container/#java-specific-notes","title":"Java-specific notes","text":""},{"location":"development/local-mq-container/#port-offsets","title":"Port offsets","text":"<p>The Java repo uses offset ports (9453/9454, 1424/1425) rather than the standard ports (9443/9444, 1414/1415) used by the Python and Go repos. This allows running integration tests for multiple repos simultaneously without port conflicts.</p> Setting QM1 QM2 MQ listener port <code>1424</code> <code>1425</code> REST API port <code>9453</code> <code>9454</code> REST base URL <code>https://localhost:9453/ibmmq/rest/v2</code> <code>https://localhost:9454/ibmmq/rest/v2</code>"},{"location":"development/local-mq-container/#running-integration-tests","title":"Running integration tests","text":"<pre><code># Start MQ and seed configuration\nscripts/dev/mq_start.sh\nscripts/dev/mq_seed.sh\n\n# Run integration tests\nMQ_REST_ADMIN_RUN_INTEGRATION=1 ./mvnw verify\n\n# Stop MQ when done\nscripts/dev/mq_stop.sh\n</code></pre>"},{"location":"development/local-mq-container/#environment-variables","title":"Environment variables","text":"Variable Default Description <code>MQ_REST_BASE_URL</code> <code>https://localhost:9453/ibmmq/rest/v2</code> QM1 REST API base URL <code>MQ_REST_BASE_URL_QM2</code> <code>https://localhost:9454/ibmmq/rest/v2</code> QM2 REST API base URL <code>MQ_REST_ADMIN_RUN_INTEGRATION</code> (unset) Set to <code>1</code> to enable integration tests"},{"location":"development/local-mq-container/#gateway-routing-example","title":"Gateway routing example","text":"<pre><code>var session = MqRestSession.builder()\n    .host(\"localhost\")\n    .port(9453)\n    .queueManager(\"QM2\")\n    .credentials(new LtpaAuth(\"mqadmin\", \"mqadmin\"))\n    .gatewayQmgr(\"QM1\")\n    .verifyTls(false)\n    .build();\n\nvar qmgr = session.displayQmgr();\n// QM2's attributes, routed through QM1\n</code></pre>"}]}